红黑树是一种二叉平衡搜索树, 通过一些原则保证其相对平衡, 保证查询的复杂度. 在红黑树中, 所有节点要么是红色要么是黑色, 并满足:
- root是黑色, 叶子节点是nil, 并为黑色, 一般隐藏, 无值
- 红色节点的子节点不能为红色(就是一条树链上不能有连续红色)
	- 也就是说一个黑色节点的存在在路径上隐藏了一个红色的位置
- 一个节点到其子树中的所有叶子节点的路径含有相同的黑色节点
	- 也就是说确保了子树中所有路径长度差不超过2倍率
	- 即"黑高"一致
这样一来, 全局的路径长度都没有显著的差异, 最长的高度也小于黑高的两倍

按此, 一些现象:
 - 一个R只有一个B子节点是不合法的, 这导致了黑高不一致
 - 一切颜色操作必须考虑全局黑高, 局部操作非必要不改变全局黑高
## 插入操作
由于插入一个黑色节点必然导致路径长度的变化, 代价更大, 所以默认插入红色节点
- 首先在树上找到所在位置
- 然后看是否满足条件, 即父节点是不是红色
	- 如果不是红色, 看叔叔是不是红色
		- 如果叔叔是红色, 就把父节点和叔叔节点变黑, 把爷爷节点变红(保持路径长度不变)
			- 然后需要对爷爷节点进行递归检查, 直到root
			- 这种情况如果一路冲突, 会导致整体深度+1
				- 即root和两个子节点原来是一红两黑, 现在变成三黑
		- 如果叔叔是黑色, 或者不存在
			- 如果夹在父节点和祖父节点间, 就和父节点交换然后变成下面这种:
			- 当前节点, 父节点, 祖父节点递增/减, 把中间的转上去变黑, 其余两个保持红
## 删除操作

## Ref.
[红黑树 - 维基百科，自由的百科全书](https://zh.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91#%E5%88%A0%E9%99%A4)