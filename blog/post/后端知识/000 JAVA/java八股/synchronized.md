基于对象的Monitor Lock，也称内置锁或者互斥锁，当线程进入其修饰的代码块或者方法时，就尝试获取锁，如果锁可以锁，就持有并执行，否则阻塞。
## 三种主要用法
- 修饰实例方法 public synchronized void method
	- 锁当前实例的this
- 修饰静态方法 public static synchronized void staticMethod
	- 锁当前类的Class对象
- 修饰代码块 synchronized（this）{}
	- 锁括号中指定的对象， 必须指定
## 可重入性
即同一个线程可以反复获取同一个锁， 不会自己和自己死锁
这个是检测对象头中的锁状态，然后判断其中的线程id，如果是自己，就在status上加1，计数为0表示没锁了。
如果没上锁是正常cas拿锁
## 自动释放
当代码块或者方法执行完，或者出现异常，会自动释放锁
## 非公平锁
不能保证等待时间最长的线程优先获取锁，可能出现一直阻塞
- juc锁支持公平锁

# 监视器锁， Monitor
juc中的Lock是非监视器锁，见[[juc包#Lock接口]]
他是基于jvm自带的对象监视器实现的，通过monitor控制对临界区的访问。但不是很灵活。
具体实现：
- monitor enter， 如果进入数是0，就进， 将进入数+1，变成monitor的拥有者
- 如果已经拥有，就重入，继续+1
- monitor exit, 执行的人必须是owner，执行后-1，如果减到0， 就退出
# 不同级别的jvm优化措施
在使用synchronized时，jvm会根据线程竞争情况自动选择不同的锁机制。这个是jvm优化，不需要手动指定。
但是可以用参数：-XX：+UseBiasedLocking，启用禁用偏向锁
## 无锁
刚创建， 没有被竞争，不上锁
## 偏向锁
一个线程第一次获取一个对象的锁时，就倾向与将这个对象给这个线程，记录在对象头中。此时如果一直是这个线程申请这个锁，就直接进入，不需要原子操作。
如果出现竞争，就升级
## 轻量级锁
通过CAS操作在对象头中设置锁记录， 其他线程自旋，不用阻塞
## 重量级锁
jvm通过操作系统的互斥量（monitor）实现互斥锁