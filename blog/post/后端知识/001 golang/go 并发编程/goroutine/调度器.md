# 早期golang调度器

一个全局go协程队列
调度是对队列上锁,取协程去运行

缺点:
- 调度需要内核线程去获取队列的所 ,竞争激烈
- 调度协程的时候有额外的系统负载和延迟
	- 一个协程中创建的协程可能被调度去别的线程, 没有局部性
- 大量的锁和阻塞, 效率非常低

# GMP
G: goroutine
P: processor(调度器)
M: thread
![[Pasted image 20250511223850.png]]
## P是什么
p是调度器, 但是对G来说, 这东西就像逻辑上的CPU一样, G与M不交互


# 设计策略

## 复用线程

### work  stealing
某个p的本地队列空了, 就会去别的本地队列中偷取G来执行
### hand off
如果 一个p绑定了一个m执行一个G, 这个G阻塞了, 这个p就会去尝试绑定另一个空闲的m, 然后继续执行

## 并行

最大并行数量是p的个数
即 GOMAXPROCS

## 抢占
如果有等待的G, 当前G最多执行10ms
## 全局G队列
如果一个本地队列空, 会优先去偷, 然后再取全局队列

# 创建G
在 Go 语言的 GMP 调度模型中，创建`goroutine`时决定其放入哪个队列的规则如下：

  

- **优先放入本地队列**：新创建的`goroutine`通常会先尝试进入当前`M`（机器，即操作系统线程）关联的`P`（处理器，逻辑处理器）的本地运行队列（LRQ）。这是因为本地队列是服务于当前`P`的，将新的`goroutine`放入本地队列可以减少调度开销，提升效率，并且本地队列中的`goroutine`拥有更高的调度优先级。
- **放入全局队列**：当`P`的本地队列已满，或`P`资源不足以处理新`goroutine`时，新`goroutine`则会被放入全局运行队列（GRQ）。全局队列是所有`P`都可以从中获取`goroutine`执行的队列。
满了会放一般本地LRQ的元素进去

## LRQ线程安全
LRQ是无锁唤醒队列, IO是原子操作
但是:
- 迁移时: 如果lrq满了, 需要将全局队列加锁, 然后迁移一半G过去
- stealing时, 对被偷取的LRQ加锁
	- 会偷走一半
- 