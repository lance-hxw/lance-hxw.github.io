# SQL 异象
- 脏读 dirty read
- 不可重复读 Non-RR, 或者read skew(更广义)
- 幻读 Phantom Read
- 写偏移 write skew
- 丢失更新 lost update



单对象 更新丢失
- 原子写
- 显式上锁
- 自动检测更新丢失
- CAS
- 多副本: 冲突解决(如Last write win)

多对象: write skew
- 写入条件不成立
- 是mvcc的 快照隔离级别的特有缺陷, 由于用一个不变的快照, 导致写入时数据已经变化(被另一个事务提交后改变)
- 解决: 由于多个对象, 所以原子写没有用
	- 真正避免只能可串行化
	- 如果没有可串行化, 可以利用数据库显式上锁(for update)

 幻读: 会导致write skew
 - 针对:原始数据不存在, 上锁也不行
 - 此类现象是幻读, 且难以解决
 - 解决方案:
	 - 物化冲突: 将可能导致幻读的slot物化, 可以允许对他上锁
		 - 该思路类似gap lock
		 - 上x锁的重量级实现是不可接受的, 性能还不如可串行化

# 脏写

写会干扰未提交事务的状态, 导致更新丢失

脏写是绝对不允许的, 就算是RU隔离级别, 大部分数据库都是阻止脏写的

# 脏读

读了一个未提交事务的中间状态，并且该事务最终回滚, 导致读取无意义数据

这会影响数据一致性, 即, RU一般也是不可接受的

# 不可重复读

特指读-读的异常, 即一个事务的连续读, 结果却不一样

如果事务是直接依赖第一次读的结果进行操作, 不可重复读会有影响
- 使用RR或者S可以解决
- 或者用RC + 显式加S锁可以接盘他
- MVCC也可以解决
- 或者应用层缓存读结果, 实现应用层防止不可重复读

# 幻读

特指读写过程中, 第一次读发现没有数据， 写的时候发现已经有一条记录

# Read Skew

多对象操作中, 连续读不同对象时, 出现不一致
如在"拉黑列表"读了一个被拉黑用户, 然后根据用户id查拉黑原因, 发现已经被解除拉黑了

可以在第一次读的时候加S锁, 或者基于MVCC

# Write Skew
多对象操作中, 对多个对象进行了读写操作时, 发生的不一致
如准备对一个用户进行关注操作, 但是期间用户被拉黑了, 应该不能关注了

可以加S锁, 或者MVCC 
# Update lost: 本质是没有写写隔离

就是单纯的在另一个事务执行期间修改了相关数据， 然后另一个事务又基于之前读的结果， 写入了新数据

做了写写隔离就能解决:
- 基于MVCC的写冲突检测 




# Ref.
[SQL 异象 | Spring Boot 持久化最佳实践](https://levid-gc.github.io/spring-boot-persistence-best-practices/blog/sql-phenomena/)
