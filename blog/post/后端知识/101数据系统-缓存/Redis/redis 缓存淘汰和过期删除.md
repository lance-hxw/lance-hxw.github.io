过期删除：当redis设置的ttl过期后，对应的元素会被删除
内存淘汰：如果接近了设置的最大内存，会进行内存淘汰，可能会淘汰还没过期的值
# 过期删除机制
- 惰性删除：当客户端访问(读写)到时，才检查是否过期，如果过期就删掉
	- 可以选择使用异步删除还是同步删除，异步会使用]]lazyfree[[redis 线程模型： redis使用单线程#redis 内部多线程， 主要是BIO机制
- 定期删除：定期随机抽样一部分会过期的key， 删掉其中已经过期的
	- 默认是10s一次，即conf文件中的hz
	- 每次随机抽取20，且写死是20
	- 相关策略：
		- 从有ttl的里面抽20个， 检查，删除过期的。
		- 如果过期数量超过5个即超过25%，就继续，直到一轮的低于25%
		- 然后等待下一轮检查
		- 这个过程是有时间限制的， 默认不超过25ms
- 主动删除：内存淘汰时，优先删过期的，一般不考虑这个
# 内存淘汰
redis中可以用maxmemory-policy配置如下的内存淘汰策略， 主要可以分成两大类
## 不进行数据淘汰的策略
- noeviction 默认， 不进行数据淘汰，而是拒绝后续写请求，保证删/读正常
## 进行数据淘汰的策略
### 对可能过期元素中淘汰（设置了ttl的）
- volatile-random：随机淘汰可能过期的
- volatile-ttl：优先淘汰早过期的
- volatile-lru：所有有ttl的中，最久没使用的
- volatile-lfu：所有有ttl的中，最少使用的
### 全部元素中淘汰
- allkeys-random
- allkeys-lru
- allkeys-lfu

# redis缓存过期会不会立即删除？显然不会
- 不用考虑内存淘汰，不影响
- 惰性删除中，要等到下次访问才删除
- 定期删除中，如果没被抽中，就不删除
## 为什么不立即删除：
- 需要大量cpu资源用于追踪和检查
- 如果内存资源紧张而cpu资源充裕，也可以高频定期删除