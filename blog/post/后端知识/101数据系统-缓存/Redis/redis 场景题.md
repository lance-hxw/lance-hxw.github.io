## 本地缓存，还是redis缓存
本地缓存优势：
- 访问快，低延迟， redis需要通过网络通讯，开销大
- 网络压力低
本地缓存劣势：
- 扩展性差，redis扩展性强
- 部署复杂，耦合性强；redis可以方便的部署
## 4c8g下mysql和redis并发量对比
- mysql只有5k
- redis可以到10w
## redis实现消息队列

## redis实现分布式锁
### set nx
使用set命令的争抢锁机制，只要set k v NX PX milliseconds
NX表示键不存在才设置
PX表示锁的有效时长
只要设置成功， 就认定一个client获得了锁
解锁的时候要注意判定锁是不是自己的， 这里需要用lua保证原子性
- 需要设置好value用于区分锁owner
- 一般是client把value穿过来，请后请求删除这个kv对
### redlock
使用多个redis实例实现更安全的分布式锁，要求在多数redis实例获取锁才算上锁
用以解决单点故障问题，提升了可用性

## 大key问题
某个key对应的value值占用太多内存空间，一般空间超过1m， 或者元素数量超过1w就算是。有些场景，如低延迟场景，10kb也算是
### 带来的问题
- 内存负载大， 容易触发内存淘汰， 甚至崩溃
- 性能降低， 内存碎片增加，降低节点性能，大key的读写开销都很大
- 阻塞：大key耗时长， 主线程阻塞严重
- 网络拥塞，传输时间长
- 主从同步延迟：同步传输时间长
- 数据倾斜：cluster中，有些节点资源不均衡
### 如何解决
- 大key拆分， 如将hashkey的value 拆成多个key
- 清理大key，如果这东西不适合在redis存， 就换存储
- 监控内存，及时预警
- 定期清理过期数据， 比如hash表中有的值可以去掉
## 热key
请求，网络，cpu消耗过大的key，如：
- 大量请求都在请求一个key
- 反复对一个大hash key请求HGETALL
- 反复对一个Zset请求ZRANGE
### 如何解决：
- cluster中复制热key，不过需要改名，然后分配到其他节点
	- 
- 读写分离，如果热key压力是读压力，增加从节点就可以不影响主节点
	- 但是主从就涉及转发路由等负载均衡问题。

## mysql redis一致性
先改db，再延迟删缓存
这个延迟删除操作可以直接使用mq完成，这样还可以顺便进行删除重试

另一个技术是订阅binlog，因为第一步写db成功后，binlog已经记录数据
使用Canal中间件订阅，Canal伪装为Mysql从节点，发送dump请求，mysql持续推送binlog给canal，canal给下游程序使用

这样实现了，先写db，canal及其服务端监听binlog写操作后，发出删除缓存操作到mq中。
此时，db， canal和监听服务器，和应用本体是解耦和的
- 否则要在写db的应用方法里发送msg，又需要另外的方法消费msg

## 秒杀场景和超卖现象
### 数据库排它锁
即下单为事务，查库存直接for update，立即上锁
