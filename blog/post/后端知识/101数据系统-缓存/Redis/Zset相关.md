# 底层实现
128个元素，且值小于64字节用压缩列表时是小数据场景
在新版本redis中, 用listpack取代了ziplist，所以：
- 小数据：listpack
	- 成员查找On查找
- 大数据：skip list+hashtable 组合（zset struct
	- 单成员查找，O(1), 用hash
	- 有序相关的操作，用跳表，都是log的
## zset中的跳表
- 一个sds的元素值
- 一个double的权重值
- 正向指针和反向指针
	- 前向指针数组里除了具体指针外还有跨度
- 层数:
	- 升级概率是0.25, 最高64, 在创建的时候直接创建64个头
- 头结点是额外的
## 相比b+tree
### 存储模式和访问模式: 一个针对磁盘, 一个针对内存
- B+树主要是为了优化磁盘IO, 降低树的高度, 适合批量读写, 适合范围查询
- 跳表主要是内存优化, 通过*大量的索引*, 加速内存访问性能,
	- 跳表的插入删除只需要调整少量指针, 不需要页合并和分裂
	- 通过随机实现平衡, 不需要复杂的约束
### 实现复杂度
- B+树需要节点分裂合并, 需要处理锁
- 跳表靠随机平衡, 不需要平衡操作
	- 可以用细粒度锁, 甚至直接cas, 并发度高
	- 代码简洁, 且性能相近
### 性能
- 读: 
	- 单点查询, 均为logn, 但是跳表的常数小
	- 范围查询, 其实差不多
- 写
	- 复杂度类似, 但是b树可能直接页分裂,然后触发平衡操作, 跳表只需要局部更改
		- 就算是都在内存中, 跳表插入也快几倍
### 内存占用
b+树存储元素太多, 跳表存储的很少

## 其他底层实现, zip list, listpack ,quicklist
见[[双端List, QuickList, ZipList和ListPack]]
# 应用
基本用法:
添加一个集合, 并给其中成员设置分数
```redis
ZADD set_name s1 member1 s2 member2
```
其数据结构为一个名叫set_name的有序集合, 里面成员带有分数
##  实现一个排行榜
- 使用ZADD添加元素
- 使用ZINCRBY 加分
- 使用ZSCORE查询集合中某个元素的分数
- 获取top k : ZREVRANGE setname 0 2 withscores: 切片, 倒序
	- zrangebyscore可以根据分数的值切片