# rabbit mq

只有在prefetch设置成1时, 且单消费者, 才能保证顺序性

如果prefetch>1, 可能有多个msg同时到达消费者, 如果消费者不是串行的, 那就没有顺序性

## prefetch=1, 单消费者, 有顺序性了, 如何提性能
- 1. 设置多个queue, 相当于进行分区操作
- 2. 或者把这个多个q的抽象放到消费者内存中, 单消费者消费到后, hash到多个队列中, 每个队列中保持串行, 此时顺序性需要设计(比如一串需要顺序的事件同id)
- 3. 消息序号, 每次接受一个msg后, 如果发现没收到期望的下一个msg, 就持续等待
- 4. 基于业务状态, 直接处理, 但是发现状态不对, 直接重试

## rabbitmq streams可以有顺序性


# kafka

分区内串行, 天然保持顺序性
一个消费者组可以处理多个分区, 分区并发, 分区内串行
## 分区内同步异步问题:
- 自动提交offset: poll后, 过一段时间自动提交, 还是一批批顺序拉的
- 同步手动提交, 只是阻塞提交
- 异步手动提交, 只是消费完立即拉, 但还是串行的

## 强行分区并发
消费者大量的poll, 然后交给线程池执行, kafka放弃可靠性保证
