水平拆分：结构相同，将数据放到更多库中，抗并发，和扩容
- 拆库是为了抗并发，拆表是为了锁冲突
垂直拆分：拆结构，一般将访问频率高低的字段拆分，增强缓存性能
## 分库分表工具：
ShardingSphere
插件有：
Sharding-jdbc和myCat
## 分库分表方法
- 按range分， 这个起不到抗并发效果
- 按hash分，这个迁移麻烦
# 分布式id怎么生成
- uuid: 服务本地生成，无序，也分裂
- 雪花算法
- mysql多机分片
- mysql全局id生成器
- redis INCR原子操作进行生成
- 美团的leaf （号段/雪花）模式
	- leaf号段： 服务在本地弄一个id分配表，存储每个业务的id号段
		- 从数据库取一段号段在本地服务用于发号（单点）快用完再取
	- leaf 雪花：就是雪花拉
雪花算法主要问题是不利于库表的路由，他的workerid是后端服务的id，而且这个id也需要分配
- 如果服务重启或者宕机，要workerid可能重复
- 需要时间同步，NTP
- 无法拓展
而号段模式：
# 主键（分片键）如何路由到表
[[实战, 场景与系统设计/分布式id#主键路由问题]]
# 非主键（分片键）如何路由到表

映射表：非分片键到分片键的映射，但是这样就变成单表了。不然要维护数据一致性
- 映射表就算放redis也应该是缓存
	- 还得存一份在mysql中
- 也可以启动时直接加载到内存中
	- 用分布式协调器更新配置

基因法：将非分片键的信息写到分片键中
- 然后路由的时候，直接用基因去路由

搜索引擎：用es查分片键值，走分片路由

# 如何分片

可以用分布式id路由到物理分片, 然后用其他字段在中间件上虚拟分片,中间件会维护路由表, 路由到实际物理节点上