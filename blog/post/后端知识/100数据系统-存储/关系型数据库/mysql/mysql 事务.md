mysql的innoDB中，ACID：
A：原子性， 来自undo log 回滚保证
C：一致性， 来自持久性，原子性，隔离性保证
I：隔离型， 来自M V C C多版本并发控制实现
D：持久性，来自redo log 重做实现

# 并发相关问题
## 脏读：读到了未提交事务的修改后数据，随时可能回滚，这个数据是非法的
脏读对数据一致性有恶劣影响
## 不可重复读：一个事务内多次读取值不一致，但是数据修改来自一个提交的事务，不会回滚
## 幻读：记录的存在性发生变化
或者说， 查询时发现没有，插入时发现已经在
这是可重复度级别无法解决的
## 幻读和不可重复读的区别
幻读是插入删除的问题,不可重复读是值的变化
通过mvcc控制,值是不可能变化的
但是增删操作会抹掉或者新增trx_id和roll_pointer, 无法被mvcc利用,导致这条记录不受限制
# mysql解决并发问题的手段
- 锁， 行级，表级，页级
- 事务隔离，多级别，包括：
	- 读未提交：允许读到未提交变化,
		- 不上锁
	- 读已提交：只能读已经提交变化， 但是还会不可重复读和幻读
		- 只用record
	- 可重复读：这是**默认级别**， 这意味着，一个事务过程中读到的数据一直保持不变
		- 使用next-key
	- 串行化：消除所有并发问题，因为没有并发了， 直接对记录上行级锁
		- 所有读都变成S锁
- MVCC：数据有多个版本

# 默认（可重复读）隔离条件下问题
## 幻读， 基本不出现，但是有出现的方法，即对于此前没有的数据
在a事务开始时，查询x=10， 发现没有这个记录，然后b事务提交了一个x=10的新增。
然后a也去插入x=10了，发现已经被插入了。。
## 如何解决此类幻读
在事务开启后立马执行**select ... for update** 这种语句，给记录上锁，避免插入

# MVCC(可重复读)实现原理
在一个事务begin，实现第一个查询语句后，创建一个Read View， 后续查询都使用这个readview，通过这个readview， 可以在undo log版本链中找到**事务开始时的数据**， 保证整个事务过程中数据一致。

- 对于读已提交隔离级别，是每次select都弄一个readview
- 可重复读级别， 是第一次select生成一个readview，一直用到事务结束
## readview内容, 即事务的快照
主要有四个字段
- creator_trx_id
	- 创建事务id
- m_ids
	- 创建时，当前数据库中活跃且未提交的事务id列表
- min_trx_id
	- 创建时，当前数据库中最小的活跃且未提交事务id
- max_trx_id
	- 创建时，**当前数据库应该给下一个事务的id**
对于所有的事务
即
已经提交的事务 》min_trx_id 》已经启动但没有提交的事务/m_ids》max_trx_id》还没有启动的事务
注意, m_ids中只包含**活跃事务**, 有的事务可能已经被purge(清理)了
## innodb 主索引中的记录
除了数据列外还有两个隐藏列：
- trx_id：
	- 事务对这个记录修改时，记录最新id
- roll_pointer
	- 每次修改时，将旧版本记录写到undo 日志中，并用这个pointer指向**上一个版本**。
## mvcc判定数据版本
- 如果一个记录的trx_id小于min_trx_id，说明已经提交，可见
- 如果一个记录trx_id大于max_trx_ids,说明事务在readview创建后启动,不可见
- 如果trx_id在min_trx_id和max_trx_id之间,说明创建时已经启动,此时需要判断
	- 在m_ids中,说明没有提交: 不可见
	- 不在m_ids中,说明:
		- 该事务已经提交,否则就在m_ids中: 即可见
		- 影响还在数据版本中, 否则被purge了
		- 事务id还是可见的,在min,max之间..
	这就是mvcc版本链
## purge
innodb对于undo log中不再需要的历史记录,使用purge将这些版本清除
# 串行化实现
通过行级锁实现，给记录加S型的next-key 锁，不能写
# update原子性
使用锁+undo log实现原子性

