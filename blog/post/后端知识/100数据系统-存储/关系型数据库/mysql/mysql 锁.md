# 按粒度分类
## 全局锁
FLUSH tables WITH READ LOCK
阻塞所有更新
用于： 全库备份
## 表级锁
锁表，但是并发度还是低
包括：
- 表读锁
- 表写锁
- 元数据锁：保护表结构
- 意象锁：intention lock，表名后面想在行级别加什么锁
	- 用于判断表里是否有记录被加锁
	- 在想要加行锁的时候,对表加意向锁
		- 意向锁不会阻塞其他行锁
		- 当有事务要加*表锁*的时候,用于快速判断(不需要看表里哪行被锁了)
- auot-inc
	- 表有自增字段, 会上这个,防止主键冲突
		- 默认lock-model参数是1, 连续insert上间隙锁
		- 推荐设置为2, 减少自增锁,使用轻量级的互斥量
## 行级锁
record, gap, nextkey
只锁操作的行， 并发度高，但是消耗大，在innodb中实现(myisam没有)

# 按类型分类
## S锁 共享锁，但是阻塞写
语法： SELECT 。。。 LOCK IN SHARE MODE 或者 SELECT 。。。FOR SHARE
## X锁 排它锁 ，阻塞写
语法：SELECT 。。FOR UPDATE， 或者UPDATE语句
## 意向锁 intention locks
意向共享is，意象排他ix，准备加锁，可以提升加表锁的效率
## Record Lock 锁定索引记录
防止其他事务对此行进行修改或者删除
## Gap lock 间隙锁 永远相当于是S锁
一个记录的间隙锁，一般是锁前面那个区间
*只在可重复读级别下实现*，锁定索引记录间的间隙，防止其他事务在其中插入数据
注意， 间隙锁只能锁间隙，不能自定义范围，比如非唯一索引范围查询（5，10）没命中, 但是两边值是4，20， 就只能锁（4，20）这个间隙

### 间隙锁是S还是X都无所谓, 都是可以共存的, 且功能也一样
## Next-key锁

结合了record lock和gap lock，锁定一个记录和它前面的间隙，默认在可重复读隔离下实现
可以防止幻读
## 插入意向锁 Insert intention lock
特殊的间隙锁，提示有事务准备插入，多个事务可以在一个间隙同时有意向，但要求位置不同

这是一种特殊的间隙锁
他会导致死锁:
如果两个事务同时给一个区间上了间隙锁, 两个间隙锁是共存的
然后两个事务都往里面插入,此时插入意向锁拿不到, 直接死锁
# 实际行锁类型
## 直接X锁
当update/delete的时候,直接上X行锁
## 指定s锁
select lock in share mode, 锁都是共享的
## 指定X锁
select for update, 排它锁
# 需要上锁情况
## select
- 普通, 不上锁, 使用事务+mvcc实现可重复读
	- 在innodb中, 每个sql都被当作事务执行, 就算是单独的也是自动提交,mvcc始终存在
- select for share /select lock in share mode:
	- 对涉及的行加S锁
- select for update
	- 对涉及的行加X锁
## insert 
- 普通insert
	- 插入时获取X锁
	- 使用隐式锁,只有真正需要才上锁
	- 在唯一索引上会导致间隙锁防止幻读
- insert on duplicate key update
	- 尝试插入,如果冲突就更新, 需要获取X锁
## update
- 普通update:
	- 获取X行锁
	- where条件有索引,只锁相关行
	- where用不了索引: 锁表
- 带索引的update
	- 获取意象X锁
	- 在满足条件的行上获取X锁
## delete
- 普通delete
	- 获取X锁, 根据where索引与否判断锁的范围
# 具体如何上锁，主要是为了在可重复读隔离下实现无幻读，这是最优选择
## 核心思路是，防止结果集变化
用户只能指定是S还是X锁，具体上了什么锁是根据select匹配的结果来的
而意向锁也是不能指定的，是在上s/x锁前自动加的
具体的，对于record/gap，next-key锁
**最重要的一个决定项是：唯一索引没有重复值，而其他二级索引有**
## 更重要的：当对二级索引上锁时，会去把主索引也上锁
但是只有符合条件的记录才会加锁，而且只加**记录锁**
即只有回表的才加
## 具体分类
默认是next-key这个最重的，可能降级
### 唯一索引 等值查
- 值命中：降级为record， 并上锁主索引record
- 未命中：降级为gap， 并上锁主索引id对应gap
### 唯一索引 范围查询
- 对所有在区间内的索引使用next-key，有些情况下对边界值加额外锁
- 对下列情况降级：
	- 对于“大于等于”， 如果等值命中，等值退化为record
	- 对于“小于”或者“小于等于”，还得看这个右边界命中与否
		- 如果不存在，还要在边界值上加一个间隙锁
			- 如表中1，5，10，15，查<11,会在11这里加一个间隙锁（10，15）
		- 如果存在，
			- 小于：该值前面加一个间隙锁
				- 如查<10, 加一个（5，10）
			- 小于等于：不变，即（..., 10]的next key锁
### 其他二级索引等值查询
- 值命中：可能有相同值，所以需要扫描，扫到不满足条件的记录，对所有符合条件的加next-key，对第一个不满足的加间隙锁， 然后给符合条件主键记录加上记录锁
- 不命中：扫描到第一个不符合条件的，加间隙锁
### 其他二级索引 范围查
不会退化，对所有范围内记录的二级索引和主索引加next-key锁
如between 5 and 10
锁(5-10)
### 非索引查询
# 死锁
innodb自动检测死锁
可以设置死锁timeout预防
发生死锁可以自动回滚最小开销事务

# 锁选择倾向
- 高并发用乐观锁
- 用索引，因为全表扫描会锁表
- 用相同顺序访问表和行，防止死锁
- 减少事务的粒度，不在事务中做耗时操作
# next-key锁
- record锁：锁一个索引的记录本身，如节点5
- gap锁：锁间隙，如(4,5)这个开区间，但是不包括记录
- next-key：锁一个记录和他前面的间隙，即(4, 5]
对一个左开右闭区间上锁
## 使用场景
- 在可重复读下，innodb默认对索引的搜索和扫描都使用next-key锁
## 锁降级
- 如果查询的记录刚好命中唯一索引，就只用记录锁
	- 必须刚好命中
	- 必须是唯一索引
- 如果查一个范围，或者用二级索引，才会用Next-key
## 解决幻读： 保证结果集相同，锁上任何可以将值插入结果值的区间
幻读示例：
本来有0，1，5，10，15记录
事务a：查询id between1-10，再查一次between 1-10
事务b： 插入id=2
在事务a中出现幻读
如何解决：
- 当a执行第一步select时，直接对范围用Next-key锁
	- 锁上(0,1],(1,5],(5,10],(10,15)
	- 为什么前后区间都锁上？
		- 因为按语义锁定\[1-10], 这个区间，如果不锁后面，插一个10进来就没锁住
		- next-key是将所有可能出现记录的区间锁上
## 举例
对于0，1，5，10，15这样的数据，且非主键或者唯一索引(如果是就会用gap/record)
### between 1 and 10
锁（0，15）
### id = 8
锁定（5，10）

# 避免不必要的锁
- 减少select for update, 尽可能使用mvcc
- 合理使用索引,避免行锁升级为表锁


# 隐式锁/延迟上锁, 就是先不上锁,发生各种冲突才上锁并等待
当插入一条记录时, 保存创建记录的事务ID,表示已经被隐式锁定
然后进行冲突检测, 比如:
当另一个事务尝试修改这条记录时,检查事务id
- 读readview, 发现trx_id没有提交, 发生了冲突, 将这行上锁,让当前事务等待
当创建记录的事务提交后,隐式锁释放
## 场景
- insert场景: 利用事务id
- 主键冲突:  比较主键值
- 外键约束: 外键冲突