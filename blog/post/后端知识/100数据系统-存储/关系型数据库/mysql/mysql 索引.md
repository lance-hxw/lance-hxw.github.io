mysql是一种有序数据结构（如BST）, 用于加快数据库查询的速度和性能. 
是对一列或者多个列的值进行排序的数据结构. 
索引是用空间换时间, 本身也非常大, 需要存在磁盘上, 可能存在单独的索引文件中, 也可能和数据存在一起.
如果没有索引时, 默认进行全文搜索, 遍历后放到结果中.
## 索引分类
- primary key: 主键索引, 设置主键就会建立索引，主键不能空
- 唯一索引: 唯一, 但最多只能有一个Null
- 全文索引: FULLTEXT, 可以有重复值和控制, 只能在char和varchar上
- 空间索引: 几何数据模型, 按照openGis 规则
- 前缀索引: 在char, varchar, text上建立时, 指定索引列的长度, 数值类不能用.
### 按数据结构分类
B+树， Hash索引， Fulltext索引
只有Memory支持hash， mysql内存结构中有一个自适应hash，memory不支持fulltext
用最多的是B+
### 物理存储
聚簇索引（主键）， 二级/辅助索引
这个主要涉及回表问题

### 字段特性
主键索引， 唯一索引， 普通索引， 前缀索引
- 主键索引是主键上的，非空
- 唯一索引是unique上的，可以空，可以有多个
- 普通索引， 即Index（a，b，c）
- 前缀索引，针对char，varchar，binary ， varbinary
	- 需要指定长度，Index（xxchar(lenght))

### 字段个数
单列， 联合
联合索引为
INDEX index_name ON product(product_no, name),
product是表名
一个联合索引的b+树是用全部索引列当key，当发生比较时，依次比较
## 具体存储引擎中的索引
- innoDB， 对一个表，按如下优先级，默认用B+
	- 用户指定了主键，就用主键建立聚簇索引
	- 没有主键，使用第一个非空UNIQUE列作为聚簇索引
		- 注意，如果UNIQUE是联合的key，需要其中所有列都非空
	- 都没有，就用一个隐藏自增id作为聚簇索引，但是不能加速，只是innodb自己管理数据（数据要存在主索引上）
- MyISAM： 使用非聚簇索引，索引和文件分离，读还是非常快的
## 优缺点
优点:
- 查询快
- 低io成本
- 提前排序, 降低了后续排序的cpu消耗
	- 只要按照索引的顺序返回, 就不用额外开销
缺点: 
- 占用磁盘
- 降低更新时的效率
- 维护索引需要额外开销

只应该为常用搜索建立索引
### 性别等区分度不大的不要创索引
此时检索不能优化，反而要回表，性能不如直接全表查询
## 哪些操作可以利用索引:
- where 子句
- join
- group by
- order by
- distinct
- limit
- 覆盖索引优化查询

## 索引底层结构
- B+
- Hash： 不支持范围查询， 是随机访问的， 一般用于内存
	- 也不支持排序
- R-Tree（空间索引）： myisam的地理信息索引
- 全文索引：通过倒排索引对文档进行索引

### 为什么innodb使用b+tree
- 相比bst， 层级少， 搜索效率高， 磁盘读写少
- 相比b-tree， 树的高度更低
- 相比hash： 支持范围和排序
- 相比跳表：层数容易太高
### b+tree相比b的区别
- 所有叶子节点都在一层，io延迟相同, 更加可稳定预测
- 非叶子节点不存数据, fan-out更大, 可以降低树高, 即更少的io次数
- 自平衡
	- 同时有大量冗余节点，结构变化更方便，b树还需要转移数据等
- 叶子节点使用链表链接， 便于范围查询和顺序访问
### 页内访问
一个页内的元素按主键顺序形成单向链表
使用一个页目录完成随机访问优化
页内， 将所有元素（不包括被删除的）依次分组，每组最后一个元素记录组内有多少个元素
这个n_owned字段就可以当作偏移量
页目录指向每个组最后一个元素，也就是每组最大元素，这个最大元素还记录了组内有多少元素
具体查找时，对组号二分，使用页目录辅助， 最后在页面内查询即可。

## 索引物理存储
就是表文件ibd， 运行时，发现需要请求，就从磁盘将ibd文件读到内存，需要使用索引时，会尽可能将整个索引读进来。主索引和二级索引都在一个ibd中
## 联合索引
即复合索引, 语法是:
create index idx_a_b on table_name (a, b)

如果有多个查询条件, 就可以考虑联合索引
在多条件查询中, 如果有非联合的多个索引, mysql优化器会选择哪个索引效率最高, 去使用
- 不过也存在使用多个索引, 然后取交集的情况, 这种需要优化器决定
	- 一般的, 如果返回数据量大, 集合运算复杂就会单个索引
### 注意列的顺序, 影响查询效率
一个a_b的复合索引, 可以在a查询, a_b查询使用, 但是不能在b查询使用(b_a)可以, 参考[[#隐式使用索引]]

### 联合索引应该如何设置
联合索引在创建时的顺序决定了后续索引的利用率
需要将区分度高的放在前面

## 聚焦索引和二级索引
clustered index将数据和索引放一起， 索引结构的叶子节点就保存行数据，**这种索引必须有， 且只有一个**（这是存数据的地方）
secondary index是分开存储的， 索引结构的叶子节点只保存建立索引的字段和主键（额外信息是主键， 索引字段是必须的）

如果有主键， 主键索引就是聚焦索引
如果没主键， 就用第一个unqiue聚焦
如果都没有， 就生成一个rowid索引

**注意**， 如果是用二级索引查出来的， 那么还得用主键去聚焦索引中查数据。

### 主索引的变动
索引数据变动，会导致索引结构变动
其他数据变动，只是改值，log的去修改即可
## 隐式使用索引
```sql
create [unique | fulltext] index index_name on t_name(index_col_name, ...);

show index from table_name;

drop index index_name on table_name;
```
在执行时, 遵循最左前缀或者全部出现
#### 复合索引
如果有多个字段, 如(name, age, sex), 只有特定的查询能利用上index
- 最左前缀原则, 即按顺序的一个index的前缀
	- **其实使用时顺序不重要，主要是出现的列在原索引中的顺序**
- 全部字段都在, 但是顺序不同, 可以动态调整
	- 但是不能缺值

## 索引失效
- 在索引列上进行运算，函数和运算破坏了单调性，结果没有索引，必然失效
- 字符串和数字对比，会自动发生类型转换，此时相当于用了函数，失效
	- 字符串类型数字不加引号导致
- 模糊查询的头部模糊匹配失效(尾部不失效), 对于字符串索引
- or分割开, 如果其中有个字段没有索引, 那么所有索引都失效
	- 然后进行整表扫描，因为有一个没有索引的就得扫全表，那还不如直接全表。
		- 这里主要逻辑是， and是取交集，所以可以尽量利用索引缩小候选集合
		- 但是or是并集，当需要全表扫描的时候，利用索引不能带来优化。
	- 可以用UNION替代，此时会各自扫描
		- 如果只是独立那就没任何优势
		- 主要优势来自优化：第二个查询会只在第一个查询的补集中进行
- 如果mysql认为使用索引更慢, 就失效
- 范围查询（><, BETWEEN）相关
- 非索引列上的order by
### 为什么联合索引中位于范围查询字段后面的字段无法利用
因为联合索引中后续字段都是局部有序的
如：a=10，b=4， 是现在a上寻找到10的位置，然后在a=10的元素中找b=4，全程有序
当出现了范围查询，即a>10，此时找a的时候还能用索引，但是这些a的值对应的b并没有顺序，因为要a相等才会比较b，a都不等，b是完全乱的，不能索引。

## 显式使用索引： SQL提示

可以指定：
- 使用某个索引： 
	- select * from tb_name *use index(idx_name)* xxxx
- 不用某个索引（为什么）
	- xxxxxxxxxxxxxxx *ignore index(idx_name)* xxxx
- 必须使用某个索引
	- xxxxxxxxxxxxxx *force index(idx_name)* xxx
### qa:
1. use 和force区别: use是建议, mysql会衡量性能后使用,force是强制
2. 什么情况下ignore某个索引
	- 手动忽略该场景下不适合的索引,防止mysql去花时间评估
3. ignore是强制的么: 是的, 用了就绝对不会使用
## 使用索引后覆盖 or 回表查询
- 覆盖索引: 用索引查询后, 查询的结果就是索引中的列
	- 这样使用了一个索引结构后, 直接返回查询结果就行了
- 回表查询: 数据不再索引结构中, 需要去原表查
	- 如果你用聚焦索引, 即使用主键查, 绝对不会回表
	- 如果只返回一个二级索引列和主键, 也不会回表(数据来自该索引)
	- 只有: 使用一个二级索引, 且要求返回非索引内且不是主键的值才会回表
	- 所以: 少于select \* , 非常容易回表
### 相关优化
- 如果查id, a, b三个字段, 并在b上进行where, 应该如何设置index:
	- 在聚焦索引上查不方便判断
	- 只放b索引需要回表查a
	- 故: b_a联合索引, 索引结构中也包含id， 这是考虑覆盖和回表的方法
		- 注意, 只能是b_a联合索引, 不然失效
		- id就是值
		- 能不能给a_b的索引在a上加一个通配?
			- 这纯垃圾做法, 一坨
## 字符串前缀索引
当需要对字符串进行索引时, 由于字符串比较长, 全文索引开销太大
- 全文索引好处: 查询灵活, 支持更复杂的查询逻辑
	- create FULLTEXT （title，content）
	- 可以进行相关度评分
	- 默认按自然语言模式，用关键词匹配度评分排序，忽略停用词
		- 停用词等相关配置可以设置停用词列表
		- 最小词长，中文分词（需要ngram解析器）等都可以设置
	- 可以使用bool模式， 使用+-\*等符号
- 前缀索引: 开销小, 但是只能前缀索引
	- 特别适用于项目指定的带前缀字段混在一起时
		- 但这类感觉加个col比较好
建立的语法:
create index idx_xxxx on table_name(col_name(n));
其中n是前缀长度
其中前缀长度可以根据索引的选择性来决定(或者有特殊的前缀模式):
### 选择性
计算每个前缀长度下不同的值的数量和总行数的比例, 这就是选择性
选择性越高, 前缀性能越好
唯一索引的选择性是1
计算方法:
```sql
select count(distinct email) / count(*) from tb_user;  
select count(distinct substring(email, 1, 5)) / count(*) from tb_user;
```

## 索引下推
Index pushdown是一种查询优化技术
核心思想是： 在查询执行过程中，尽可能在索引扫描阶段提前过滤数据，而不是加载了具体数据到内存后再过滤。
- 关键是，这个**失效的索引也必须是索引的字段**， 这样才能在一个索引查询中优化
索引下推主要优化在于能大量减少io， 让索引失效部分提前被处理好，而不是将大量记录传出来，
索引下推只能间接减少回表行数。
- 减少回表行数主要是，如果你在二级索引中查完，其中有索引失效，回表的时候还要大量对比
	- 你在二级索引中下推完，直接就拿到primary key了， 方便很多。
### 采用索引下推的变化：
- 常规： 
	- 扫描索引和表，获取所有记录
	- 进入sql层进行过滤和计算
- 使用索引下推
	- 使用索引过滤一部分
	- 将满足的记录传回。
### innodb的索引下推
即ICP，index condition pushdown， 优化带有索引的where字句
如，在where a>30 and b = 10时， 传统是将a>30利用索引查出来，然后在内存中过滤b
现在是在索引中直接把b=10也判定掉，减少回传。



## 索引设计基本原则
### 对于数据量大且查询频繁的表建立索引
如果查询很少, 根本不用建立索引, 开销大, 比如日志

### 如果一直在更新， 就别索引，不然代价很大
### 将常被用于条件,排序和分组的字段建立索引
### 选择选择度高的建立索引, 如唯一索引
效率高
### 如果是很长的字符串类型, 可以尝试前缀索引
### 尽量用联合索引, 尽量保证覆盖
### 控制总索引量, 太多的索引影响增删改的效率
想想红黑树的修改啥的
### 如果索引列不会有null, 就在创建时加上notnull约束!
如果优化器知道每列有没有null, 决策效率更高(不用考虑null)

