# 插入数据
- 批量插入(1000条以内), 就是()()()()
- 事务
- 主键顺序插入, 减少页分裂,减少碎片, 并且总写在最后一个子节点, 减少io, 减少竞争
- 大批量插入:使用mysql的 load
# 主键优化
- 降低长度
- 使用顺序插入, 使用自增主键
- 不要用UUID和自然主键, 用自增ID!
- 不要改主键!
# order 优化
order有两种方式：
- Using filesort: 通过索引或者扫描,读取相应数据后, 在排序缓冲区进行排序
	- 只要不是通过索引直接返回的排序都是filesort
- Using index: 通过有序索引直接返回数据
	- 如果order的字段全在一个索引中
	- 且order的字段全是升序或者降序, 就会直接用索引返回
	- 否则会同时走index然后filesort
### 即:
- 设计好索引, 多字段的索引注意定义索引时指定的排序
- 必须要用filesort时, 增大sort_buffer_size, 默认是256k
# group 优化
还是利用索引
# limit优化
如果只取一页, 朴素查询时会查这一页和前面所有数据, 然后丢掉其他部分, 开销非常大
可以使用覆盖索引和子查询优化
- 但是子查询里面似乎不能用limit
即:
- 先用一个子查询按主键排序查一页的主键
- 然后在原表中使用主键查询出值
# count优化
MyISAM将每个表的总行数保存在磁盘上, 但是在不用判断的情况下
innodb没存, 只能累计

优化: 如果有需要可以自己计数, 如redis中存一个total

count(x), 遍历每行, 如果x非空, 就累加

count(主键)需要遍历所有数据的id值, 然后累加
count(字段)如果没加not null约束, 还会判断一次, 判断在服务层实现, 引擎返回所有数据, 有约束, 就不需要判断
count(1); 遍历整个表, 但不取值, 服务层对每层放一个1, 然后累加
count(\*): 不取值, 特殊优化, 服务层对每层累加

效率排序: 
count(字段) < count(主键) < count(1) <count(\*)

最好用count(\*)
# update优化(关于行锁和表锁)
innodb的行锁是在索引上加的, 不是在"记录"上加的, 并且查询中, 索引不能失效:
- 如果在聚焦索引上update, 此时索引不失效, 在id索引上上行锁
- 如果在一个别的字段update, 且没有索引或者失效, 锁整个表
即: 
	加索引!!!, 不然会锁表