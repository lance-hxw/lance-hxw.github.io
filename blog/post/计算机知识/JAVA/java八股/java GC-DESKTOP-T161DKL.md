释放不被引用的对象,一般在如下场景触发:
- 内存不足, heap不足,自动回收
- 手动请求, 即调用System.gc()或者Runtime.getRuntime.gc()
	- 但是这是建议, 不一定执行
- jvm参数, 如设置-Xmx, Xms等设置heap最大值和默认值,调整gc
- 对象数量或者内存阈值.
# 垃圾判定算法
## 引用计数
给每个对象分配一个引用计数器,当计数器为0就标记为可以回收
缺点:
- 循环引用
## 可达性分析
从GC root集合中的对象出发,递归追溯他们引用的对象,如果一个对象到roots没有任何关系,就不可达,标记为可以回收
GC roots对象有:
- stack中引用的对象
- meta space中静态属性引用的对象
- 本地方法stack中JNI引用的对象, 活跃线程的引用.
# 垃圾回收算法
- 标记清除: 造成大量碎片
	- 标记, 通过可达性分析,标记要回收的对象
	- 清除, 统一回收所有需要处理的对象
	- 缺点: 会形成大量碎片空间, 内存利用效率低
		- 而且标记清除的效率都不高(虽然没啥更快的)
- 复制: 为了解决碎片问题
	- 将内存分成两块,每次申请时使用其中一块
	- 内存要不够时,将所有存活的对象都复制到另一块上,然后把另一边清除,
	- 但是这样只能用一半的内存,效率更低了
	- 如果存活对象非常稀疏是可行的, 否则缺点太多
		- 但是老年代不太可能稀疏
- 标记整理
	- 先标记
	- 然后将所有存活对象都移动到内存的一端顺序排列
	- 然后清理其余部分
- 分代回收
	- 就是新老年代
	- 一般Tenuring Threshold是15
# 垃圾回收器

![[Pasted image 20250227153734.png]]
高吞吐的适用于计算后端, 高响应的适用于服务端
## 标记复制算法: 与MinorGC契合, 将Eden移动到Survior或者老年代
- Serial, 新生代, 单线程, 简单高效
- ParNew, 新生代, serial的多线程版本
- Parallel scavenge, 新生代, 并行, 追求高吞吐, 高效利用cpu
	- 适合对交互要求不高的
## 标记整理:
- Serial Old, 老年代, 单线程
- Parallel Old, 老年代, 并行, 搞吞吐, 不追求交互应用
## 标记清除
CMS, 并行, 老年代, 目标是最短回收停顿(STW), 响应速度优先
使用CMS时, 在新生代会用ParNew
## G1 : 全heap, 复制+标记整理, 响应速度优先
不产生碎片 高响应
他弱化了分代的概念，而是使用分区
最常用
他将整个heap都分成区， 然后再分给不同的年代， 也不固定每个代大小，可以动态分配划分。
GC时直接全heap进行， 不过是先对给新生代的区进行
- 他对年轻代的区进行*复制*
- 对old进行*整理*

## ZGC， 并发， 分代， 低延迟，大堆
现在zgc和g1用的多，大吞吐用Parallel GC

## Shenandoah GC， 并发，大堆， 低STW，JDK12+
在整理时并发，并且STW时间和堆大小无关

# STW stop the world, 就是app进程停下来让GC运行
>在标记阶段需要前后两次STW保证正确性
>在涉及对象数据复制转移重定向时, 都要STW
>但是清除不需要S T W， 但是有浮动垃圾问题

G1中
在复制算法中, 先标记, 再转移, 最后重定位
在标记过程中, 为了正确性需要app停下来, 但不用全程停下
- 初始标记, 在可达性分析第一步, 从root出发时, 会STW, 但是耗时非常短
- 并发标记, 对所有对象并发可达性分析, 不用STW, 但是耗时长
- 再标记 , 标记那些在并发标记阶段变化的, STW, 耗时比较短
清理:
- stw, 不清理对象, 只计算内存分区中有没有存活对象
	- 这和g1的分区契合
转移复制阶段: STW
- 重新分配内存, 耗时短
- 复制对象的成员变量
	- 写对象头很快
	- 实例数据可能很大
G1的主要S T W停顿在复制实例数据时.

# MinorGC, MajorGC, FullGC, 触发场景
## MinorGC
对新生代回收, 清理Eden和S区
在eden满时进行, 发生非常频繁,不过新生代清理效率高，因为全死了
## Major GC
老年代回收, 但也可以清理新生代
在老年代空间不足或者新生代tenure太快， 要炸了
频率低
## FUllGC
heap回收， 在主动请求gc时尝试full gc
如果MinorGC后存活对象没地方放了， 就进行full GC
FUll GC必然STW然后遍历整个堆。

# 浮动垃圾
在标记为垃圾后， 还没清理， 这些就是浮动垃圾，他们在这期间可能被引用，变成活对象
这个问题出现在标记问题， 一般的三阶段标记尽量解决， 但不能完全解决
在最终清理/整理阶段
- 如果选择并行清理， 这样不需要STW， 但是并行导致了浮动垃圾问题， 因为app进程在活动
- 如果选择stw然后复制/整理， 这样就没有浮动垃圾问题


# 对比CMS和G1
- CMS是老年代， 默认配合ParNew， G1是full heap
- STW时长：
	- CMS追求最小STW
	- G1的STW可以预测
- 碎片
	- cms是标记清除， 有碎片
	- G1是复制或者整理， 没碎片
- 过程， 三阶段标记后， G1会复制/整理， 而不是清除
- 浮动垃圾问题
	- 如果浮动垃圾太多， CMS就得STW进行单线程清理
		- 而且得预留内存空间给浮动垃圾
	- G1没有浮动垃圾问题
## 使用
cms： 低延迟， 老年代， 允许碎片化
g1: 大内存， 碎片敏感， 停顿和吞吐均衡。
	停顿可控


# meta space GC
如Class卸载， 这种不是GC管理的， 是classloader之类的回收机制完成的， 是jvm通过加载器生命周期进行的。