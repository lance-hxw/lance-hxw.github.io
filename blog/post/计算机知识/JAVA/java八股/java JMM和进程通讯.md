关于对于一个共享变量，对这个共享变量的写操作后，其他线程的可见性问题

# cpu缓存模型
cpu cache的工作方式：
- 复制一份数据到cpu cache中
- cpu需要数据时直接从cache中取
- 运算完成后，将结果写入内存
此时就出现了数据不一致，即对一个数据进行两次操作，可能只修改成其中一次的结果
cpu使用了MESI等协议用于解决一致性问题
这种一致性是通过对bus总线进行类似锁的操作完成的

# OS内存模型
os是虚拟化硬件底层的，所以也需要处理缓存-内存不一致问题 
此时解决方案为内存模型MM，不同的os有不同的内存模型

# 指令重排：只保证串行语义
为了提升性能，会重排：
- 编译器优化（jvm/jit等进行了优化，但没考虑并发
- 指令并行重排（如果不存在数据依赖性，就进行重叠执行
## 解决：
- 禁止编译器指令重排
- 对处理器插入内存屏障，禁用特定类型的重排
	- jmm就是写的时候强制刷主存
	- 读的时候强制更新缓存
# 内存系统也会出现主存和本地内存（分配到的）不一致


# JMM
java期望提供语言的mm（因为jvm）， 但是有缺陷，会暴力关闭编译优化。
后续jmm发展成了和并行相关的一套规范和抽象。
遵守一定规范，通过使用volatile， sync. , lock,就可以实现并发安全

## jmm中的线程和主存
共享变量可能存放在本地内存中，此时就与主存不一致
此时jmm要求对共享变量的读写操作必须去主存同步

不过这只是简单的可见性保证

## jmm同步操作
- lock
- unlock
- read
- load
- use
- assign
- store
- write
## jmm同步规则


# happens-before