# 为什么需要线程同步：保护竞争资源(数据)

# 相关概念
- 串行化：实现了对一个资源的独占访问，就是串行化
- 原子操作：一组操作要么执行成功，要么失败，没有中间状态，就是原子的
# 基于锁的同步
## 互斥锁
- acquire
- release
只有两个状态：locked和unlocked
一般互斥锁的接口，如果尝试获取锁，失败，就会阻塞
如果不想阻塞，一般有trylock之类的接口，如果失败就立即返回
基于锁的获取，使用，释放的同步机制必须所有线程都遵守，不然还是会出错
## 读写锁
三个状态：读锁，写锁，未加锁
三个接口：加读锁，加写锁，解锁
这个的并发度更高，可以提升吞吐量，允许同步读，用于读大于写的场景

## 自旋锁
Spinlock类似互斥量，但是原理不同，不是阻塞等待，而是忙等待
自旋锁的使用前提是，期望所有竞争者在acquire后很快就release，即等价于：自旋的成本比阻塞（线程调度）低
使用自旋锁的操作一般临界区代码都很简短。
### 对于内核态线程来说：这个期望是很容易的
内核态的中断处理函数可以关闭调度，避免cpu抢占，而且有的内核态线程调用的处理函数根本不能睡眠，只能用自旋锁。
### 对于用户态线程，推荐使用互斥锁
虽然临界区可以简短，但是持有锁的时间还是会很长。
在分时多任务os上，如果时间配额耗尽，或者在抢占式os上，出现了更高优先级的task，会导致当前任务被调度走，不能控制自己持续自旋，这时候被调度自旋就完全是浪费cpu资源，不如直接等待（反正同样会被调度）

### linux中的自旋锁：基于mutex
加锁的时候有限次数的自旋，然后进入睡眠让出cpu

### 特别的：自旋锁只能用于多核系统中
如果是单核系统，直接死锁了（活锁）

## 死锁
两种典型原因
### ABBA锁
两个资源XY分别被AB两个锁保护，如果持有A想访问Y，同时另一个线程持有B想访问X，就会死锁（非抢占，占有等待，循环等待，互斥）
这个的解决一般是：trylock，不阻塞，或者锁排序，即不同线程对一系列资源的获取都按相同顺序，可以称为锁排序
### 自死锁
即对非重入锁，自己获取自己持有的锁，就会死锁

## 轮询与条件变量
条件变量思想是，不需要竞争者一直查看资源是否可以获取（轮询）
而是用一个互斥锁保护一个条件变量实现”条件“的逻辑
线程改变条件之前先**获取锁**，**改变条件**，然后**解锁**，**发出通知**
此时等待者醒来，尝试获取锁，然后再**判断条件**，如果条件不成立就释放锁继续睡眠

## lock free 与 无锁数据结构

同步可以分成阻塞和非阻塞
- 互斥量，信号，条件变量都是阻塞
- 无锁的情况下实现同步，是非阻塞
锁是阻塞的，主要缺点是，会挂起程序，如果持有锁的程序崩溃或者hang了，那么锁就不会释放

什么是lock free？
- 允许单个线程饥饿，但是保证系统的吞吐，即至少有一个线程在推进，而不是全局阻塞
- 