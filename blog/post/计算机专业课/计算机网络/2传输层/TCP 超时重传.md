使用TCP标准RTO机制计算进行重传
# RTO计算：
基于RTT（往返时间）测量值动态计算，并按重传次数进行指数退避
通过计算Smoothed R T T，不断测量和更新（按0.875的记忆率
然后计算RTTVAR衡量RTT波动，最终得到平均且考虑波动的RTO
一般来说，RTO应该略高于R T T
- 如果过大，需要等待太久
- 如果过小，出现突发延迟可能多发
典型时长差不多1s级别，最长可能有60-120s
如果丢包，RTO翻倍
# 与MSL的概念区别
RTO是TCP协议的一部分，MSL是IP层的一部分
典型时长30s-120s
linux一般是60s
# 重传上限：一般5-15次，os设定
超过后强制关闭
linux默认15次
win是5次
BSD是12次和6次（SYN
按10次计算，10次重传总耗时差不多300s附近
linux15次重传可能耗时10分钟

# 生产环境配置
## 高吞吐server
降低重传次数，降低syn重传次数
缩短FIN wait
缩短keepalive
## 异步（高延迟）server
高重传次数，高重传超时

## 数据库server
积极的keepalive检测（短时长，低超时阈值）

# 快速重传
超时重传缺点非常多
- 总要等RTO
- 另一方的报文持续没有ack，也以为丢失了，也进入重传
- 一旦发生超时重传，下次时间间隔就会加倍
	- 拥塞控制会让cwnd减半， 同时RTO翻倍
快速重传就是，三次重复ack（代表三个丢包）就进入重传（同步进行拥塞控制）
这解决了超时时间问题，但是还需要决策：
- 重传一个，还是重传所有
	- 因为不知道哪个哪些报文没收到（一直在ack第一个丢的包
	- 此时不知道重传第一个包还是全部后续包
- 解决方法是SACK，带选择确认, 告知接受了什么数据
	- 额外发送丢失了什么数据段
		- 即对于2，3，4，5数据的2丢失时
		- 这样响应3: ack2， sack3-4
		- 这样响应4: ack2， sack4-5

此外，还有DSACK，继续在SACK扩展，告知发送方，有哪些数据自己重复接受了，用于辅助发送方判断是否发生了失去顺序，ack丢失，重复和伪重传。
- 如ack报文丢失，一旦接受到一个ack，就知道并不是自己数据包丢失，而是ack丢失，可以推断网络状况