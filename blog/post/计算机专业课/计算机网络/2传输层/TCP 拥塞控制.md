流量控制只能避免发送方数据超过接收方处理能力（缓冲）
现在还需要控制网络整体拥塞情况
即，当网络已经拥堵的时候，不能继续发包
- 否则， 发包就会失败，失败就重传，重传包就更多了。。
TCP是“无私”的，如果网络发送拥塞了， 就降低发送



拥塞控制策略主要有四个：
# 慢启动：指数增长
建立tcp连接后，一开始不发送大量数据，而是先探测拥塞程度，逐渐增加拥塞窗口大小，如果持续不丢包，每个ack增长加1，如果丢包，就减半
 - 注意这里，实际是每个ack带来的增长+1，即cwnd个ack后增长一倍
 - 但是cwnd变大后，每次都会有更多的cwnd
 - 即每个RTT中，cwnd翻倍

慢启动有阈值，当cwnd达到threshold后，进入拥塞避免，停止指数增长

# 拥塞避免：线性增长
一般ssthresh是65535B，达到这个阈值后
每收到一个ACK，cwnd +=  1/cwnd，注意等于每一轮增长1
这相当于每个R T T，cwnd+1（每个RTT内接受cwnd个ack

# 拥塞发生：降低上限，根据情况决定慢启动还是快速恢复
发生丢包后：
- 超时重传
- 快速重传
## 如果是RTO超时后重传，就应用拥塞发生算法
- 将慢启动阈值设置为cwnd/2
- 将cwnd设置为1
- 开始新的慢启动
丢包意味着此前的发送速率支撑不了，直接将上限减半

## 快速重传
发送方受到三个连续重复ack就快速重传，而不是等待RTO
- 接受到三个重复ack意味着发送方的最近三个包丢了，接收方以为自己ack丢了在重传
此时
cwnd /=2
阈值设置为cwnd
然后快速恢复
这种方法不会剧烈减少发送速率

## 快速恢复过程
一般是和RTO同时使用的，快速恢复的意义在于：
**如果有三个重复的ack接受到**, 说明拥塞并不严重，只需要将cwnd减半，不需要重新慢启动

然后快速恢复过程中，
cwnd = sshthresh +3（三个丢失数据
重传丢失的数据包
如果又有重复ack，cwnd+=1（此时窗口右端没动），继续重传
- 这里之所以让cwnd持续增长，是为了将重传失败数据与正常窗口隔离，
- 一开始有三个丢失数据，就重传三次，后续失败越多，就预留越多位置用于重传
重传完成，接受到新的ack，说明已经恢复，此时将cwnd设置为慢启动阈值，然后进入拥塞避免阶段
