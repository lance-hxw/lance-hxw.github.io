# 建立

三次握手

A主动发起，B被动打开TCB进入监听

- A建立TCB，发出SYN=1，seq=x，syn报文不能有数据，但占用序号。A进入SYN-SENT
- B接受到，发送确认：SYN=1，ACK=1，ack=x+1，选一个初始序号seq=y。无数据，用一个序号，B进入SYN-RCVD
- A确认：ACK=1，ack=y+1，自己seq=x+1,可携带数据，如果不携带，就不消耗序号，此时下一次seq还是x+1，此时进入ESTABLLISHED。B收到，也进入。
## 两次握手的问题：
- 旧连接： 如果很久前发的建立连接请求现在才收到，对面发回来一个响应，这边不知道这是啥，那边也以为连接已经建立。
- 可靠性验证：
	- 验证client发送能力
	- 验证server接受，发送能力
	- 验证client接受能力
	- 缺一不保证可靠
- 增加攻击可能，如SYN
	- 此时没有第三次握手，更无法区分合法请求和半连接DoS
- 同步序列号失效：没有三次握手，client无法确认server的序列号
- 无法处理重复连接请求，即相同握手

## 如果丢报文：
- 丢第一次报文：server无反应，client没接受到ack，超时重传，否则失败
- 丢第二次ack报文：server响应，client没接受到ack，超时重传，server阻塞等待ack，也等不到，于是进行重传，直到上限
- 丢第三次报文：server超时重传，server重传到上限，client以为建立成功，发送数据，数据到server后，响应RST报文，消除单方面连接状态。
## 第三次握手数据包？
第三次握手client认为已经建立了连接，所以可以发送数据
第一次握手不可以，因为此时两边根本没有完成连接， 会被用于半连接攻击
# 释放

四次挥手

A主动关闭

- A发：FIN=1，seq=u，u为前一个数据最后字节的序号+1，A进入FIN-WAIT-1，不带数据，消耗序号
- B收到，进行确认：ack=u+1，seq=v，ACK=1，B进入CLOSE-WAIT
- （伪）A接受后，进入FIN-WAIT-2，等待B发出连接释放报文
- B发完所有数据：发送TCP释放报文：FIN=1，过程发送了其他数据seq=w，但ack=u+1，即重复，进LAST-ACK
- A收到释放报文后：ACK=1，ack=w+1，seq=u+1，进入TIME-WAIT，然后经过2MSL，A进入close，B接受后close

即A发完数据后主动关闭，B表示知道，记录A的seq，B发完数据后也发FIN包，请求seq+1，A发送序列号为seq+1的包表示接受B的FIN

时机：主动发起方发送第二个FINack后会等待一会进入TIME-wait然后关闭

## TIME WAIT期间响应fin会不会刷新？
不会，防止陷入循环，资源耗尽

## 为什么要TIME_WAIT两个MSL：基于假设2msl让所有报文都过期，边界情况需要额外处理
MSL即maximum segment lifetime，报文最大生存时间，超时报文就被认为过期。

- 如果自己发的FIN-ACK报文丢失，此时对方会认为是不是自己的FIN丢失了，一个MSL后会超时，发出新的FIN，我方需要等待到此时完成响应。如果2个MSL期间没有新的FIN请求，
- 防止过期报文：等待两个MSL后，自己此前发送的所有报文都失效，响应也失效，不会有旧的报文干扰下一个连接
这个逻辑是，此前自己发送的全部报文，和这些报文的响应，都会失效。
但是对方重传FIN处理不了
## 旧报文有什么影响
相同五元组的情况下，可能被错误接受，这个需要os额外处理
如果序列号在新连接序列号空间外是没问题的，如果刚好在接受窗口内，就完蛋
### os特殊处理 
- 时间戳，用时间戳防止旧报文干扰
- 优先用长时间没用的端口
- 序列号空间保护，防止序列号重叠
## 为什么TIME WAIT只等待两个MSL

正常情况下，两个MSL之后的FIN重传非常罕见，两个MSL足以完成断开操作

## 既然只能等两个MSL，为什么FIN能一直重传？

重传不是用MSL计算的，两个MSL内，FIN一般已经到达上限了。

## 最后一个数据包：如何确认ack报文被接受？处理不了
- 超时重传
	- FIN发送者没收到 ACK会等待，并进行超时计时，然后重传FIN包
	- 对方接受FIN包就知道自己之前的ack没发出去
- TIME_WAIT
	- 发送ACK后自己等待2MSL
	- 如果期间收到新的FIN包，就处理（所以要等待两个MSL，因为第一个MSL是正常等待过期）
## TIME WAIT结束后
一般来说2个MSL结束后，对方已经FIN重传上限了，如果还有新的包过来，本地tcp的tcb已经被删除，此时会响应RST包，要求强制终止不正常连接


# TCP半连接状态
在三次握手过程中，server接受了client的syn包，但没有完成第三次握手，此时处于半连接状态。
即：第一次握手完成，第二次握手还没有发出，或者第三次握手没有发出
在这个过程中，这个连接会一直放在server的半连接队列中，直到超时或者拒绝。

## 半连接队列
tcp开始握手前，server从close状态变成listen状态，此时创建两个队列，syn队列和accept队列
其中，半连接队列存放没有完成的连接，accept队列存放已经完成的连接
server接受第一次握手，回复了ack和syn后，就将这个连接放进半连接队列
当接受第三次握手，此时连接会被推到accept队列，然后等待应用取走（调用accept）


半连接队列中的内容是五元组+其他信息
全连接队列中是established状态的完整socket结构，包含五元组和tcp连接信息

# TCP 等待计时器 RTO
发送一个需要响应的包后，进行超时计时
# keepAlive 计时器
在tcp连接已经建立时，如果一方故障，如何评估是否保持连接
这个一般是每次接受数据后，就刷新计时器，一般时间设置为两个小时。
如果2个小时内都没有受到数据，就发送一个探测报文，然后每隔75s发一个，持续发送10个后都没有响应，就认为出现故障，然后关闭连接。
# 挥手的close wait 和time-wait
closewait：被动方处理自己还需要发送的数据
timewait：主要是确保旧数据包彻底消失

# TIME WAIT过多有什么问题（只有主动发起方会time wait）
占用内存资源
占用端口资源
## 解决：
- 长连接：time wait由于自己的ack是没有响应的，所以不可避免，所以最好是减少断开次数
- linux设置TIME WAIT状态端口复用，SO_REUSEADDR

