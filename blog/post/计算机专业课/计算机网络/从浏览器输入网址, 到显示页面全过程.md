核心两个点: ip是起点和终点, mac是一跳和下一跳
# 应用本地预处理(应用层)
## HTTP处理

url解析发现是http协议的
于是生成一个http请求报文
## DNS

现在根据url中的主机名找服务器, 但是可能是一个域名, 此时需要查域名对应的ip地址

此时使用迭代或者递归的方式不断请求上层dns服务器, 最后获取实际ip地址

浏览器本地会有dns缓存
## 操作系统协议栈

现在要发送一个http报文到指定ip地址的指定端口

在os层面自顶向下:
- 应用程序与socket库交互, 到这里都是应用层
- socket 与 os内核tcp, udp, icmp, ip等协议栈交互
	- 这里主要是传输层(tcpudp)和网络层(icmp, ip)两层
	- socket与传输层交互, 传输层与网络层交互
- 协议栈通过驱动程序操作网卡与外部网络交互
	- 这后面是物理层

# 准备发往网络(从传输层到数据链路层 下降)

## TCP
此时要封装TCP报文
http报文被当做数据放到tcp报文的数据字段中
将端口放到tcp报文中, 同时传递dns获取的目标ip到ip协议层
## IP
此时要封装IP报文, 将目标和源IP地址都放进去
TCP报文作为IP数据报的数据, IP包头协议号写成06, 表示TCP

### 如果有多个网卡怎么办?

会和本地路由表中的记录进行匹配, 如果和目标ip同一个网络, 就发送, 否则不发.
都不匹配就匹配默认网关, 发给路由器

## MAC, 点对点传输

现在要封装mac报文, 就是在IP头部再加一个mac头
包含了接收方和发送方的Mac地址, 并附加协议类型:
- TCP:0800
- ARP:0806

### mac地址怎么获取
发送方只要根据网卡读取就行

目标方的mac地址怎么获取?
- 显然需要某种形式的路由表, IP-mac形式
- 此时需要使用ARP协议帮助找到目标MAC
	- 发送arp广播
		- 如果在同一子网, 直接用arp响应填充
		- 如果不在同一子网, 此时会走默认网关
			- 将mac地址填这个网关的地址

当不在同一子网时, 该mac帧点对点传到路由器上, 路由器再通过他的网络层协议, 在ip层找目标, 再封装mac帧去传输, 直到终点

mac帧的作用就是在通过ip找到目标机器的时候, 将数据传到那台机器上

# 进入外网(从物理层到网络层 上升)
## 网卡

网卡负责将网络数据包通过电信号传出去

首先网络包到达网卡的缓冲是, 然后在上面加上报头和起始帧分界符, 并加上帧校验序列

## 交换机

交换机的目的就是将网络包原样转发到目的网络, 工作在mac层

交换机是没有mac地址的, mac帧不是发给他的, 而是经过他在网络间传递, 他维护一个mac地址表, 记录每个mac地址在他的哪个端口上

将这个mac帧发到对应网络就行了

如果找不到对应地址, 说明目标机器很久没发请求到这个交换机上了, 此时就直接广播, 让接受者自己接受, 其他忽略

对方接受后, 会进行响应, 将自己mac写进来, 所以不会负载很大

全1就是广播地址

## 路由器
路由器工作在L3网络层, 路由器是有mac地址的, 类似计算机

路由器正常接受mac帧, 获取IP数据报 , 然后根据路由表进行转发

- 转发需要匹配, 逻辑是使用对应记录的子网掩码按位与后, 匹配网络, 匹配就转发
- 如果一个都不匹配, 就走默认路由/默认网关
### 具体发送
查询完, 如果发现要去一个gateway, 说明那是一个新的路由器, 此行是再去转发
如果发现网关是空, 说明现在ip报中的目标ip就是终点

找到目标ip后(下一路由器或者终点), 通过arp协议找mac地址, 进行下一跳
- 先找arp缓存
- 没有就用arp查询

然后再下降, 填写两个mac地址变成mac数据帧

# 接收端
接收端收到IP报文, 然后拆成tcp报文, 进而得到http报文, 获取了数据
这个过程也是在对方的"网卡-os协议栈-应用"中走了一遭




