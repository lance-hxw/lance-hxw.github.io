# 不用ssl/tls时http的问题
- 身份伪装：
	- 伪装服务端
	- 伪装客户端
- 明文通讯，直接窃取数据
- 报文可能被篡改，无法校验
## 中间人攻击：伪装server和client，获取全部信息
# 两种加密方式
## 对称加密的特点
- 密钥简单，加解密速度快
缺点有：
- 必须双方提前约定加密规则
- 每个client都需要不同密钥，所以需要管理大量密钥
- 不安全环境下无法建立通讯
## 非对称加密的特点
非对称加密的算法复杂度很高，不适合长期使用

公钥加密，私钥解密，是用于client到server的加密通讯
私钥加密，公钥解密，是**签名算法**，只用于校验证书
- 签名可以验证发送的对象（持有私钥），同时还可以进行完整性校验

优点是：
- 私钥不传递，非常安全
- 可拓展，公钥可以公布，不需要约定密钥

# 流程(单向验证)(RSA)
部署前：服务器安装证书
- client hello ：client生成随机数R1， 发出请求，并告知自己支持的加密算法
- Server hello ：server生成随机数R2，选择一种加密算法作为会话密钥生成算法
	- 然后响应，发送证书，R2，和加密算法
- client获得证书后
	- 取出公钥，解密数字签名，校验身份问题，向CA校验证书合法性
	- 取出会话密钥生成算法，随机数R2
	- 用R1，R2，R3生成会话密钥，将R3用公钥加密发送给server
- server使用私钥解密，得到R3，使用R1，R2和R3，以及自己指定的算法，得到密钥
	- 然后server还会发一次确认, 表示握手完成, 并弄一个摘要给client校验
	- 后续使用会话密钥对称加密通讯
		- 性能比纯非对称好
## 三个"随机数"
- R1: client 随机数
- R2: server随机数
- R3: 预主密钥
## 主密钥
server和client基于同样的算法，使用三个数生成主密钥
## 会话密钥：由主密钥派生
用于client到server和server到client的加密/校验
- 加密密钥和mac密钥
这还允许会话中更新密钥，而不用更新主密钥

## 双向验证 mTLS
- 就是客户端也有证书
# https加密了什么：建立连接后，http的头部和正文都会被加密
但是url会暴露在各种历史记录中，所以url不安全
不过即使在握手的时候，url在数据包中也是加密的
- 因为先tcp连接上，再tls连接上，然后才发送http数据包，此时完全加密了
# 如何向CA验证
## 发证书：
ca将包括持有者公钥在内的所有信息打包，计算一个hash
使用ca私钥将这个hash值加密，得到证书签名，将这个签名放在证书上。
## 校验：
解密成功后，还检查有效期，然后利用ca的撤销列表或者在线状态协议验证状态
- CRL和OCSP
还要验证域名

### CRL
证书吊销列表, 记录被撤销的证书序号, 这个不是很实时, 并且很大

### OCSP 这个用的多
在线证书状态协议, 直接返回有效状态, 直接返回一个证书的状态, 比较小, 而且实时性强

### OCSP stapling
ocsp请求太多会导致CA服务器繁忙
所以可以让请求者去轮询, 按时间戳和结果去缓存状态, 结果带上签名防止篡改

## 证书链校验
客户端获取证书的时候，会获取所有证书，即证书链，包括server证书和所有中间证书
根证书一般不用，是有个信任列表的。

# ECDHE 握手

RSA类型的握手可能存在前向泄密, 也就是服务器私钥被攻破, 导致数据泄露

目前广泛使用的是ECDHE密钥交换算法
这是基于对数运算的
## DH算法, 这个是双向验证
首先约定模数p和底数g
然后双方各自使用ab两个数作为各自的私钥
然后用$g^a mod p$ 得到公钥A和B
从A和B反向算ab是很难的
然后双方互相交换AB, 此时双方除了各自私钥ab外, 还有pgAB
然后计算对话密钥$K=B^a mod p = A^b mod p$ 
这个K也是反向算不出来的

## DHE算法
static DH中, 有一方私钥静态(server), 那么就有泄露风险, 类似RSA
DHE双方的私钥都临时, 是双向安全的

## ECDHE
EC是椭圆曲线, 双方选定使用什么椭圆曲线, 和曲线上一个点G, 然后使用类似流程, 得到会话密钥
这个计算量更少, 性能更好, 安全性同样有保证

## ECDHE握手
同样四次
- client 选择ECDHE套件, 发送tls随机数R1
- server 确认, 生成一个内部随机数, 计算自己的公钥, 并发送
	- s公钥
	- 证书
	- (可以要求对方证书)
	- tls随机数R2
- client 校验证书, 生成一个内部随机数, 并发送
	- c公钥
	- (证书)
	- 此时会得到一个预主密钥K
- server:
	- 生成预主密钥K
	- 进行最后的确认(将数据摘要用对称密钥加密让client校验)
- 后续: 派生会话密钥进行通讯
	- 派生会话密钥是基于R1, R2, 和K的

# 重点!关于TLS和会话密钥生成算法

R1和R2是tls协议层的规定, 密钥协商算法还会生成一个密钥
这个密钥在RSA中就是client的预主密钥R3
在ECDHE中, 这个密钥是双方协商的共享密钥K

然后根据密钥派生算法, 基于R1,R2和密钥, 得到最终会话密钥

然后在具体会话中, 再加上标签, 派生出各种密钥


# TLS1.3
相比1.2四次握手, 1.3中
- client hello: 发R1, R3/c公钥
	- 注意, 这样就没有交换密码组件了
	- 此时要对每个支持的曲线计算公钥
- server hello: 发R2, s公钥
- client第一个http请求
	- 此时生成会话密钥(R1,R2, K/R3)
- server响应第一个http请求
	- 生成会话密钥

这样就只要2次握手

这是理论过程, 实际上, tls1.3不准用RSA, 所以就是单程的ECDHE

