
# 报文结构
## 请求行：方法，URL， HTTP版本
如 GET /index.html HTTP/1.1
## 请求头：Host，Accept，User-Agent等
## 空行：在头和正文之间，表示头部结束
## 正文：可选，Post中有表单数据，get没有

## 响应状态行：HTTP版本，状态码，状态信息
如 HTTP/1.0 200 OK
## 响应头部：如服务器类型，响应类型Content-Type Content-Length
还有Last-modified Expires等
# HTTP版本：最常用已经是2
## 1.0: 默认短连接
无状态，完全独立
非持久连接，但是可以用设置keep-alive强制开始长连接
## 1.1： 默认长连接
默认长连接
流水线处理，支持客户端在前一个响应到达之前就发送下一个请求
- 但是服务端必须保证按收到请求的顺序返回响应
- 相当于解决了请求端的队头阻塞, 但是解决不了响应端的队头阻塞
- 不过pipeline不是默认开启, 而且浏览器基本都不支持, 所以还是只当http1.1只是默认长连接好了
## 2.0 多路复用
1.1的最大问题就是延迟太高

使用二进制而不是文本格式来传输数据，解析高效
- 使用headers和DATA两个二进制帧, 而不是一个表单
多路复用：一个TCP上进行多个Http请求响应，解决1.x的队头阻塞问题
- 就是一个大请求在头部阻塞住了后面的所有请求
- 基于stream概念, 一个tcp连接对应一个stream或者多个(tcp复用)
	- 多个stream可以乱序, 只要保证同一个stream中的请求处理是有序的
- client收到不同stream传来的resp,通过streamid组装成http报文
头部压缩，由于无状态，所以必须每次都带上所有信息，就引入头部压缩
- 基于HPACK算法压缩头部, 使用字典中词语的索引对头部进行压缩, 这个字典是huffman出来的
服务端推送：server可以主动在长连接中向客户端推送
- 比如nginx中设置http2_push 某资源, 就会主动推送
- 也是基于stream, 不过是反向的, 主动发起推送, 并告知data在哪个stream
## http3.0 ： 基于quic，快速udp连接

- http3还简化了帧结构, 并优化了头部压缩算法

相当于http-quic-udp-ip-mac的协议栈，而不是传统的http-tls-tcp-ip-mac协议栈

基于udp的连接， 可以在传输的过程中完成tls加密握手，更快

quic是一个融合了部分应用层(如tls)的传输层协议

### 解决队头阻塞
基于udp, 本身就没有阻塞问题, 安全性通过序列号保证, 丢失后要求重传就行. 并且对其他报没有影响, 更不会影响stream

### 握手延迟
http2先tcp握手, 再tls握手, 要3个RTT(1.3 2个)
并且tcp有拥塞控制, 所以刚建立的tcp不能慢速运行

quic这边, 直接一个RTT, 融合了tls直接确定双方连接id, 就能建立连接

重连时, 只要继续用id传输, 就是0RTT的

### 网络迁移重连
一个tcp用(源ip,源端口, 目标ip, 目标端口)确定
如果网络迁移, 这个连接就不可以用了

quic中, 连接id不变, 就还是一个连接, 还是正常通讯, 不用重连
