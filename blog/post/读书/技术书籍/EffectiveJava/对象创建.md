# 静态工厂而不是构造器

意思是直接在类里面写个静态工厂
主要优点：
- 自定义创建逻辑，可以实现单例等
- 有具体方法名，可以允许同参数不同逻辑创建
- 可以返回子类对象（也就是父类去写工厂
	- 这和interface相当契合
	- 由于历史原因（java8前接口不能有静态方法）
		- 一个ABC类往往有一个ABCs类提供工厂方法
		- 如Collections，里面实现工厂方法获取集合实例
	- 这样可以用接口来引用，而不是具体实现类
- 返回的具体类，可以在写工厂的时候还不存在
## SI，API， Service Access API， SPI
这类模式称为服务提供者框架，如JDBC
他是这样一个系统：
- 多个服务提供者实现一个服务
- 系统为客户端提供多个实现，并将客户端和多个实现解耦
SI是提供者实现的接口
API是提供者用来注册具体实现的
Service Access API是可以访问的实例
SPI是服务接口实例的工厂对象，如果没有服务提供者接口，就使用反射进行实例化
从java6开始，提供ServiceLoader作为服务提供者
## 静态工厂的缺点
- 类需要有public或者protected的构造器，才能子类化
	- 如果父类构造器私有，子类根本不能实例化
	- 不过这可以促进使用组合模式而不是继承
- API上不写的话，程序员根本不知道有什么工厂
	- 可以使用一定规范如
		- from：转换方法
		- of：聚合方法，将多个参数聚合成一个实例
		- instance或者getInstance方法，获取实例
		- create或者newInstance获取新实例
		- getType，返回对象类型
## 总结：public构造器和静态工厂需要权衡使用
# 多参数时使用Builder
使用builder能显著降低需要编写的构造器数目
不然就是排列组合了
一个朴素解决方案：先创建java bean，然后使用set填充值，但是这样太随意了，可能出现异常状态（即参数冲突，无法限制）
此外，java bean不可能是不可变的
使用builder是更好的实现
具体的，一个bean的内部写上一个public静态内部类Builder，其有若干构造方法，对应主类的一个参数，并返回一个Builder
最终用build返回一个主类实例

# 单例模式强化：私有构造器和枚举类型
两种常见
- 内部持有静态final实例，私有构造器
- 使用静态工厂getInstance和一个静态实例
	- 方便扩展，可以是泛型的（子类的泛型
## 单例与反序列化
每次反序列化的时候要避免重复创建新单例对象
需要实现一个readResolve方法，直接返回成员instance、
## 单元素的enum
定义为一个单元素枚举类型是简洁，方便的序列化（不会重复实例化）
但是如果存在超类，就不适合

# 私有构造器强化不可实例能力
工具类不能实例化，此时就应该提供一个私有构造器
- 此时编译器不会生成缺省的构造器
注意不要尝试设置成抽象类，这等于说：你应该继承然后实例化其子类

# DI是最优选
获取实例的一个简单实现是静态工具类+单例类
# 少创建对象
能用valueOf等静态方法就