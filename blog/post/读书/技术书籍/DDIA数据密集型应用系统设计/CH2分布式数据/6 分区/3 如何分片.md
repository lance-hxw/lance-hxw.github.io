可以用kv存储来考察, 其他数据都可以转换成kv存储.

一般来说, partition是对数据集合的划分, 实践中, 一般细分为两个步骤:
- 对数据集的逻辑划分
- 将逻辑分片调度到物理节点

基于这个过程, 分片需要满足:
- 划分逻辑分片应该保证均匀
- 需要最终到物理分片的路由关系, 这个过程可以直接端到端, 也可以走逻辑分片再到物理分片
	- 退化版本: 知道可能在哪几个分片
	- 最差: 全分片查, 不可用.

这两个过程是正反两个方向的, 是一个权衡, 如果分片简单, 路由就复杂

一般路由做法有:
- 基于固定规则, 正反相同规则路由, 如hash
- 使用内存存储映射关系
- 结合两种, 先基于规则算逻辑分片,然后记录逻辑分片到物理分片的映射
	- 比如基于规则按hash分桶, 然后说这个桶在一个节点上

# key range 分区
若key定义域有明显顺序性, 基于key的定义域分区是非常直觉的, 但是由于不一定天生均匀, 所以需要动态调整

比如, 如果key是时间戳, 那这个分配到最新数据的分片就会承受所有的写.
- 这种解决方案是分级或者混合
- 找一些其他的分片键融合进来
# hash 分区
直接基于hash进行分片, 只要hash函数选的好, 就足够均匀, 一般直接用MD5就行
一般来说, hash后的结果就是均匀的, 直接按hash的值域进行均分即可完成逻辑分片.

### 一致性hash
一致性体现在, 数据是通过hash进入环的, 所以只要规则不变, 就能保持一致性. 

节点的变动只会影响环上的一小部分, 比如删除一个节点, 他前面一段的数据会落到后面那个节点.

但是基于hash分片难以进行范围查询, 此时一个范围查询需要拆成所有条目全量查询

这种解决方案是, 基于组合, 先hash再用另一个键排序. 这个效果是, 对特定的分片键, 查询这个分片键下的范围数据效率高. 比如某个用户的一段时间的操作

但是在分片键级别范围查就不行了.

# 对比
key 是应用相关分区, 支持高效率范围查询
hash是应用无关的分区, 可以均摊负载, 但不能高效范围查.

使用多个键组合二者就能获取部分优点

# 负载偏斜和热点消除
如果访问是完全随机的, 那么在数据层hash就可以做到足够均衡

但是在应用层数据本身就是不均衡的, 比如一个非常多粉丝的用户, 用他的userid路由后, 他去哪哪里就是热点

此时必须要在应用层进行热点消除

- 拼接主键, 即将userid后面加上一个随机id
	- 但是这会在读的时候增加复杂度
