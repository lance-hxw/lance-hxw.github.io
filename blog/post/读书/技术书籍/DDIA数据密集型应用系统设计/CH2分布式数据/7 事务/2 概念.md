# rethinking ACID

不同数据库总是给出不同的ACID支持, 特别是isolation的区别, 现在acid已经变成口号了
## Atomicity

原子性保证可以理解为: 发生错误时, 回滚该事务已经写入的变更
这是一个单客户端概念, 与重试相关.

## Consistency

一致性用的很多, 具体在数据库场景, 一致性是对某种不变性的支持, 即某种约束条件

这种约束条件可以理解为系统数据合法性的约束, 如余额, 收入, 支出之间的约束关系

不过一致性是和应用强相关的, 所以这是一个应用层和数据库共同维护的概念

可以这么理解, 一致性其实是数据库基于原子性和隔离性对应用层提供的保证, 是应用层的一种属性, 所以"C是用来凑数的"

## Isolation

多客户端并发访问数据库时, 如果访问的数据没有交集, 就可以随意并发, 单如果有交集, 就会有并发问题, 或者竞态条件(race condition)

一般来说, 隔离性就是指可串行化, 即保证事务可以认为自己是唯一的运行事务.
但是可串行化的实现太强了, 性能太差
所以一般都会提供各种弱隔离性支持(即保证有限的隔离性)

## Durability

持久性即, 事务一旦commit, 无论服务如何宕机, 都不会丢失数据

在单体数据库中, 持久即数据页或者日志写入了非易失性存储
在多副本数据库中, 持久即多数副本写入成功

但是持久性也是有限持久保证, 即在数据库层面的保证
- 如果磁盘坏了
- 或者多数节点都坏了
就无法保证持久性

但是持久性特别重要, 所以一般要尽可能完善地处理:
- 写入磁盘后宕机, 数据没丢, 为了高可用, 可以使用多副本系统
- 多副本如果在单机房, 可能同时故障, 所以还需要定期持久化到外部
- 异步复制中, 如果主副本宕机, 没有同步的数据可能丢失, 需要WAL日志且落盘
- 突然断电导致磁盘写入失败
- 磁盘寿命到了, 需要备份

无论如何, 都不可能完美保证持久化, 数据库层的持久化保证只是基础

# 单对象操作和多对象操作

支持多个对象操作的事务是更强的保证

多对象事务的另一个议题是, 如何确认多个操作是同一个事务:
- 基于TCP, 同一个连接中BEGIN TRANSACTION和COMMIT间所有内容是一个事务
	- 但是中间网络断了就歇逼了, 不知道提交没
- 逻辑上考虑: 使用事务管理器, 给每个事务分片id, 记录事务操作进度和提交状态
一般都是逻辑上事务id

## 单对象写入

单对象也要原子性和隔离性

这是最基本的保证, 就算一个数据库不准备提供完整事务支持, 单对象事务的原子性和隔离性也是必须的, 否则根本不安全
- 最简单的, 可以用undo实现原子性, 用锁来隔离

部分数据库支持原子自增等操作(不过原子自增应该是隔离性范畴, 他不是单客户端修改要考虑的)

不过有的数据库把单对象操作的保证宣扬为事务支持就很不对了

正常来说, 事务必须支持: 多对象多操作封装成一个执行单元

# 界定多对象事务的需求

不过话又说回来了, 多对象并非必须, 因为实在太损耗性能(数量级), 分布式数据库都选择不做这个支持, 也有的数据库将其作为可选项.

所以决策权交给了应用侧, 是否真的需要多对象事务? 单对象事务能否满足需求?

...虽然确实很多时候需要多对象:
- 关系型数据库的外键更新
- 文档性数据库由于不支持join, 所以要冗余, 此时要同步多个数据
- 次级索引的同步更新
这些也可以在应用侧支持, 不过复杂度和性能缺陷不会凭空消失.

# 故障和终止

事务的设计哲学是: 当遇到要违反原子性, 隔离性和持久性的危险操作时, 直接回滚
不过一些场景(如无主模型)中使用了尽力而为的模型, 即如果不能完成也不回滚, 这类处理方式需要应用侧处理这种半完成的状态.

如何处理?直接重试?
重试最简单但不一定好:
- 如果事务已经提交， 返回时出错, 重试就会导致重复
- 如果系统负载高导致事务失败, 重试会导致负载进一步加重
	- 应该指数退避+最大重试次数
- 临时错误: 死锁, 异常, 网络抖动, 故障切换 是可以重试的, 但是永久故障重试没用
- 如果事务在数据库之外有副作用, 重试会导致系统混乱
