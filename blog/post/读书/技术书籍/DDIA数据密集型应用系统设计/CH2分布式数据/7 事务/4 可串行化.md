弱隔离级别太过复杂, 不仅开发人员容易写出bug, 甚至各个数据库实现都不一致

可串行化是最容易想到的, 可以解决这些问题的方案, 但是可串行化问题实在太多.

可串行化主要实现方式有:
- 物理串行
- 2PL
- OCC, 乐观并发控制, 如可串行化的SI

本节主要讨论单机上的实现
# 物理串行
直接将事务串行执行, 这个性能非常差, 甚至由于太差, 要等到近些年, 这种"朴素"的方式, 才能真正落地, 这主要归功于RAM变得非常大, 不用去IO事务的数据, 同时AP和TP区分开, 对于AP场景, 物理串行是允许的, 同时只提供一个一致性快照

voltdb, redis, datomic都是物理串行, 吞吐很好

## 存储过程

使用物理串行的一种优化, 其思想来源是, 对于访问OLTP的实际业务, 一个事务必须足够小, 因为要追求响应时间

但是这样, 在处理多语句事务时就会有太多次请求. 所以不允许交互式多语句事务, 这种需求可以将多语句封装在存储过程中, 一次性交给数据库处理

存储过程早就在SQL标准中, 但是一直风评不好

- 每个数据库都有自己的存储过程语言, 但一致的是, 都非常古老
- 在数据库执行业务逻辑, 难以调试, 监控
- 一个业务写的性能差原本只会拖慢服务性能, 放在数据库会直接导致数据库不可用.

现在的存储过程一般是用java, lua来写的

对于单线程事务, 存储过程还是挺有效的, 吞吐会提高

对于一些分布式部署的数据库, 还可以用存储过程来实现同步, 即在多个节点执行相同的存储过程, 不过这要求执行后结果完全一致

## 数据分区

单线程虽然快, 但是也是制约系统整体吞吐的瓶颈, 所以可以进行分区, 提供吞吐.

此时最重要的就是要保证大部分事务能在单个分区上完成(即不用分布式事务)
- 分布式事务比单机事务低若干数量级
- 且难以通过增加资源来缓解

数据分区的前提是数据建模与分区比较契合, 比如KV存储就比较方便, 但是如果是有多个索引的数据, 无论用哪个key进行分区, 其他索引上的访问都是跨分区的

## 什么场景可以用物理串行
- 事务小, 快, 否则就是灾难
- 纯内存数据库, 否则io事务数据是不可接受的
- 分区足够简单, 有限的分布式事务
# 2PL

两阶段锁是使用最广泛的可串行化实现(这里是SS2PL, strong strict two-phase locking)

即将锁的使用过程分成两个阶段, 扩张阶段和收缩阶段. 
与事务对应:
- 扩张阶段就是事务的执行期间
- 收缩阶段就是事务的commit
在扩张阶段, 只申请锁, 在收缩阶段, 只释放锁.
实现一个事务实现流程的简化
- S2PL就是, 将写锁保持到事务结束
- SS2PL就是, 将读写锁都保持到事务结束

**2PL其实最本质的就是: 统一释放锁**

这样实现后, 就保证了一个事务能访问的所有数据都不会被其他事务干扰

此时就不会有任何并发, 也没有update lost , write skew等并发问题

2PL是innodb的S实现, 是DB2的RR的实现
这样的实现显然是会导致死锁的

## 性能问题
2PL最大问题就是性能, 会导致性能显著低于弱隔离级别
- 延迟不稳定, 由于无法并发, 所以任何长事务都会导致其他事务性能下降
- 死锁频繁: 2PL的死锁会远多于别的级别
	- RC: 一行上的S和X锁等待, 锁升级等
	- RR: 区间gap lock导致死锁
	- 级别无关: 写写冲突导致死锁
## 谓词锁

就是不只是行级别锁, 而是要对一类(区间, 类型)记录上锁, 是为了避免幻读

其本质就是对对象集合上锁, 包括其中可能添加的元素

## 索引范围锁

谓词锁是动态获取的, 所以活跃事务很多的时候, 性能就很差, 此时大部分2PL数据库都会用近似实现: index-range locking , 或者说next-key locking

这种近似一般都带有对谓词锁范围的放大
- 因为多条件情况下, 这个谓词锁必然是离散的
- 此时一般: 直接选其中一个条件, 在这个条件对应的索引上进行next-key locking
	- 这个条件必然是该索引最左边那个
有了这种近似后, 就变成一个有索引的范围锁, 可以非常方便地进行冲突检测
- 从而保证串行




# (SSI)OCC, 乐观optimistic concurrency control
如SSI,  可串行化快照隔离


## SSI , 高性能+强隔离
如今, 无论是单机数据库, 还是分布式数据库, 都用SSI的身影, 虽然还不够成熟, 但是其性能优势, 已经让其有了成为可串行化默认实现的趋势.

SSI是基于快照隔离的, 他对所有的读取都获取一份一致性快照, 然后在SI上, 再进行写写冲突检测算法, 然后决定如何重试

## 乐观(optimistic)与悲观(pessimistic)
2pl是悲观并发控制, 即预先上锁
物理并发更是悲观, 直接不准并发
SSI则是乐观的并发控制, 其思想是:
- 如果存在潜在的危险, 还是直接尝试执行
- 事务提交时, 进行冲突检测
- 如果有冲突, 重试
没有任何锁, 但是执行完需要检查

一般来说:
- 乐观意味着一定程度的cpu开销, 如果系统负载已经接近上限, 并存在大量竞争, 此时重试会导致更严重
- 如果系统空闲, 此时用乐观就能降低时延
## 前提失效, 如何决策(重试)
如何进行重试, 或者说如何进行决策, 就是上述所有事务隔离的核心, 即对于任何读-写操作中, 如何进行写的决策.

此类场景中, 读是写的前提(premise), 如果写的时候, 前提不再满足, 那写就没有意义

对于可串行化隔离级别, 这种因果关系必须识别并判断是否终止事务

即, 检查读后有没有新写, 读是否过时

## MVCC 过时检测(被动)

由于快照隔离是基于MVCC的, 所以很容易出现这种过时现象(允许并发)

复杂度不会消失, 允许并发, 就导致基于mvcc读的事务在提交的时候必须要做过时检测

## 提交时判断是否干扰其他事务(其他事务读过旧数据), 主动

检测到干扰, 然后提交的时候进行通知(写写并发的时候, 慢的那方接收到过时通知), 被通知过时后, 要判断自己需要重试与否, (如果是读事务, 不用)

## SSI的性能
- 相比2PL: 不阻塞, 性能接近SI, 读写互不阻塞, 特别是对于大量读的场景
- 相比物理串行: 不局限于单cpu单线程, 可以拓展, 只要冲突检测适配系统
	- 分区场景更方便的分布式事务

使用场景: 
- 事务尽量短(只读没事)
- 不过还是要比2PL和物理串行对长事务容忍性强.(其他两个就是不可用了)