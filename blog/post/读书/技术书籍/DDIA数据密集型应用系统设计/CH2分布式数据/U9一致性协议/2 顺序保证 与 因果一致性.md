顺序保证实质上是期望因果保证, 顺序往往可以维持因果性

一般来说, 可以认为, 两个并发的事件互不知晓,而先后发生的ab两个时间, b必然知道a, 或者说, 读到b了, 这个读取结果中必然有a

也就是说, 顺序可以当做因果

在数据库事务的一致性快照中的一致性, 就是指因果一致性, 也就是有b必有a

这是应用层需求的

# 因果序非全序
## 全序

total order表示系统内任意两个元素可以比大小, 比如自然数就是全序, 但是有的概念是非全序的:
如, 集合, 如果互补为子集就不方便比较(incomparable)
集合是偏序(partially ordered), 即只有部分情况下(如存在子集关系)可以比较,  其他情况下不可比

## 因果序就不是全序

线性一致性中, 所有操作都像是在单副本上, 所以可以认为是全序的

因果一致性中:
- 存在因果关系的就可以比较, 是有序的(happens-before)
- 但是并发的就不可比较
所以因果序是偏序的, 或者说只有存在并发现象, 就是偏序的

## 并发

并发意味着时间线的分叉和合并, 当合并的时候, 来自两个时间分支的操作就可能不可比

## 偏序, 有向图, 因果关系, 一致性

如果用一个有向边表示因果依赖关系, 如果因果图中一个路径能遍历所有事件节点, 且没有环, 说明是线性一致性的.(线性一致性是一种全局关系, 全序关系)

而因果关系是一种局部特性(偏序关系), 定义在两个点上, 即两个点直接相连, 因果一致性就是图上没有环


# 线性一致性强于因果一致性

线性一致性是因果一致性的充分条件
- 线性一致性是(有向无环图, 且存在一条单向路径遍历所有事件)
- 因果一致性是(有向无环图)

因果一致性事实上是在存在故障的情况下, 维持高可用的最强一致性了.

很多情况下, 应用层说要一致性, 其实往往只是需要因果一致性, 此时如果能在应用层分辨哪些操作需要因果一致性, 提供因果追踪, 然后让其他请求随机执行, 这样性能会非常好. 不过因果追踪的代价非常大.

# 捕获因果依赖

实现因果一致性的前提是捕获因果依赖关系, 我们可以将这种关系称为节点拥有的"知识"的一部分, 即, 在执行b的时候, 是否知道a的存在

在多个节点中追踪所有key的因果依赖, 可以使用版本向量来标记. 同时, 对于每个事务, 都需要追踪起读取的数据时什么版本

# 序列号

追踪所有因果依赖是不切实际的, 在很多场景中, 会读很多数据后再写
此时他们之间因果关系混乱, 如果要追踪全部读的集合的版本, 就非常麻烦

直接用序列号/时间戳是最简单的方式, 可以是物理时钟/逻辑时钟, 比如记数器

比如事务id, 通过这序列号, 就能提供一个全序关系. 这相当于将原来的有向图上, 将独立的节点用有向边补全, 并得到一个串起所有节点的DAG

在主从模型中, 主模型生成日志集合, 同步后, 所有节点都能保持一致

## 非因果序生成器

如果没有单一主节点, 即多主/无主, 或者出现了分区. 此时就难以生成一个序列号了.
常用方法是:

- 每个节点/分片生成不相交的序列号, 比如奇偶, 或者预留机器码
- 使用日历时钟(但需要非常高精度)
- 每次批量生成一组序列号, 使用一个中心

不过这些都不能保证全局的因果一致性, 比如一个服务发号快,一个慢, 一个机子时钟慢等等

## Lamport

一种优雅的解决方式

每个节点有唯一的id和一个记录处理过多少操作的记数器
一个Lamport时间戳就是(counter, node Id)

即每个node的单独序列号, 此时就全局唯一了, 且局部递增(局部因果一致性)

且比较时, 先比counter, 若counter相同, 比nodeId

不过关键在于: 每个节点都控制自己的counter, 让他追上看到能看到的最大值, 比如本来counter是10, 但是接到一个请求,counter100, 就调整自己的也变100. 那么这个请求发起者要进行的后续操作, 即"果"的counter必然大于100, 会同步到将要请求的数据节点

只要最大的counter被一直传播, 就能保证调用链条上需要保持因果关系的事件的counter递增.

要求整个系统中所有事件, client, server都使用Lamport, 才能追踪系统中的所有因果关系

Lamport能保证具有因果关系的两个事件不会混乱, 不过不代表有大小关系就有因果关系, 即无法分辨是普通并发还是happens-before, 

比如两个节点自己没有交流, 在一直自增, 他们两个节点的状态虽然有大小关系, 但没法比较

版本向量是可以的, 版本向量每个分量只有自己可以修改, 所以两个版本向量的统一维度是可以比较的. 只要比较全部的分量, 就可以判定happens-before和并发关系.

## 序列号/时间戳的不足

只提供了理论上的保证, 但是我们回想一下出发点, 我们是要解决分布式系统的一致性问题. 但是序列号方法都依赖于网络的通畅. 所以在寻找全序关系的时候, 还需要注意全序的构建来源

# 全序广播

如果只是单节点那最简单了,一个记数器. 

使用时间戳/序列号的方法不能容错

单主模型由于有权威的leader, 可以容纳从节点故障, 但是:
- 单主负载承受不了, 如何扩容
- 主节点宕机如何failover

这个问题或者说场景就是全序广播, 或者原子广播

全序广播是一种多个节点交换消息的协议, 要求系统:
- 可靠交付: 如果一个节点收到, 所有节点都要收到
- 全序交付: 每个节点收到顺序一致
并且要求系统在任何情况下都满足, 无论是网络故障还是节点宕机
- 虽然此时肯定有节点送不到, 不过可以重试, 并实现最终一致性

## 全序广播应用

- zk和etcd的共识协议
- 数据库同步(状态机复制), 即保证收到加顺序一致, 所以状态转变完全一致
- 可串行化事务, 不会乱序, 接收到就处理, 能在网络通讯环境下实现串行化
- 日志, 这种性质可以当做日志
- 锁, 能明确上锁顺序

## 全序广播实现线性一致性的存储

比如我期望系统中的用户名唯一性:

需要设计一个寄存器, 支持CAS操作, 初始为null, 当想使用一个用户名时, 需要在旧值是null的情况下设置值为a, 就算修改成功, 要保证原子性, 只能成功一个.

现在我们用全序广播系统实现一个日志追加服务, 支持此寄存器功能

- 首先追加一个带有用户名的消息, 表示想占用某个用户名
- 不断读取日志, 直到读到刚才追加的条目
- 检查所有想要该用户名的消息, 如果发现你写的信息是第一条, 你就成功了, 否则终止请求

这当中全序广播在哪?
- 全序广播保证了信息按顺序到达所有节点, 非常好的性质

这样实现了写的线性化, 但是读不是, 你多读几个节点, 就可能有新有旧, 这个可以叫时间线一致性, 
 - 这个可以用读顺序化实现, 即将读也当做消息, 一个节点发起读请求, 当这个请求最终写入的时候, 才能执行读操作, 此时对所有节点的读都是有序的
 - 或者直接查询最新版本是什么版本,  看同步进度, 比如zk的sync
 - 将读取路由指向写入的脚本, 或者写入严格同步的节点(如链式复制)

## 用线性一致实现全序广播

线性一致的系统, 用起来就像单点, 那就用这个"单点"给消息编号, 即一个严格单调增的记数器/整数寄存器

- 消息丢失? ACK 或者异常判断

这个消息号和时间戳/序列号是很不同的, 这个必须连续, 也就是说你没收到4, 就不敢处理已经收到的5

但是, 实现一个线性一致的记数器是很难的:
- 单机: 不是HA
- 集群: 一致性问题

所以, 这样一个线性连续序列生成器,必定和共识算法有关

综上, CAS线性寄存器, 全序广播, 和共识协议是等价的
只要解决其中一个就行
