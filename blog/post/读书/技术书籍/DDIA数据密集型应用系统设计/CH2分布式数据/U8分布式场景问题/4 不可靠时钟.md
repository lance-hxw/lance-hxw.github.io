时间间隔和时间点都是系统中的关键数据, 但是都很难获取

# 日历时钟

或者叫挂钟时间, 与现实时间强相关, 即相较于1970.1.1.00.00.00的时间戳(一般是ms)

日历时钟一般基于NTP进行同步, 即底层是gps/原子钟性能的分层同步协议
- 在ntp同步中, 如果一个机器的时间差距太大, 会直接被重置, 此时这个机器就出现时间倒流/时钟回拨
- 而且日历时间不计算润秒

上面两个问题, 导致日历时钟计算时间间隔不是很可靠

# 单调时钟
单调时钟能保证不回拨, 所以计算时间间隔更加可靠

一般都实现为物理石英钟, 如果多个cpu之间有独立的计时器, 也需要在os层面抽象出一个单调的时钟, 不过最好不要严格依赖这个单调性

如果与ntp不一致, 一般是调整时钟频率, 但是幅度非常小. 关键是, 不会直接拨动时钟.

单调时钟比较可靠, 可以用来本地计算时间间隔, 不过精度也不是特别高

# 时钟同步与精度问题
单调时钟不是太关心同步, 日历时钟必须要时刻保证同步

通过NTP同步的过程是不可靠的
- 硬件会漂移
- 漂移大了会回拨
- NTP不可访问就会无法同步
- NTP访问延迟会导致精度下降
- 闰秒需要特殊处理, 如摊平/拖尾等
- 用户乱改

不计成本的话, 还是能获取较高精度的时钟的, 比如交易所

# 警惕时钟依赖

如果你设计的系统依赖系统各个节点的时钟同步, 就必须警惕时钟不同步带来的宕机, 数据错误

一般来说, 必须检测节点的时钟偏移, 出现问题, 需要移除节点

## 用时间戳决定顺序
此时如果时间不同步, 就会导致逻辑错误, 因为逻辑(顺序)依赖于同步时钟

一般出现在后者胜(LWW)设计中

## 最好依赖逻辑时钟

逻辑时钟不存在与物理同步失效的问题
即将业务逻辑与物理时间解耦合, 增加复杂度, 换取可控, 稳定
[[逻辑时钟与物理时钟]]

# 时钟置信区间

虽然我们读到了ms级别的数据, 但是不代表其精度有这么高
考虑石英晶振漂移和NTP同步误差, 我们不应该将时间戳看作可靠的时间点, 
而是应该将读取到的时间, 逻辑上转换成一个带有置信区间的时间范围处理

具体置信区间根据时间同步来源的精度决定

大部分时钟同步服务不会给出这个置信区间, 需要自己评估, 不过truetime等会给出最早最晚时间, 非常有趣

# 如何用物理时钟实现可靠顺序关系?
对于分布式事务, 我们需要统一可靠的分布式事务id, 这一般依赖于一个统一授时中心

但是spanner基于物理时钟实现了这个功能, 其思想就是返回一个时间范围用于逻辑判断
只有在"确信必定有先后关系" , 才做出逻辑判断, 否则不做判断

不过门槛是非常高的, google在机房里放原子钟

由于授时中心实现复杂, 性能差, 所以很多人在尝试基于物理时钟作为逻辑顺序

# 进程停顿
进程停顿是不可避免的, 而在分布式系统中, 进程停顿带来的影响非常巨大:
- 任何时候都可能停顿: io, 时间片轮转, gc
- 程序无法知道自己停顿了多久, 只能依赖时间
- 也就是说, 任何与物理时间耦合的逻辑, 都无法可信完成, 都与时钟同步相关.
# 如何编写强实时系统

大部分情况下必须要做实时系统, 减少响应时间, 一个延迟无界的系统在很多场景下不可接受, 如自动驾驶程序就不能stw进行gc

不过实现实时系统代价很大
- os层面: 需要防止时间片轮转的停顿
- 依赖: 所有依赖都要有时间保证, 不能无界
- 内存: 不准动态(这样必然有gc, 有gc必然stw)
- 可观测 + 测试: 足够详细的测试, 保证实时要求


不过这种强实时系统一般吞吐都很低, 一般来说不需要这么极致, 我们只要考虑停顿和时钟问题, 并做出一定优化, 保证系统可用即可

## GC对时延的影响
延迟敏感的系统一般会让gc实时追踪对象分配速率和可用内存, 然后在需要gc时, 先与程序沟通, 然后让程序进入特殊处理, 将请求拒绝掉, 让其进去别的节点, 然后进行可控的stw

另一个想法是, 只用短时对象进行快速回收, 对于old对象, 通过定期重启来回收
重启的时候, 拒绝服务, 分流到别的节点, 整个流程类似滚动升级

不过都不治本, 但可以缓解gc影响
