默认分布式系统中节点之间不共享资源, 如内存和磁盘, 故主要依赖网络通讯, 而网络本身非常不稳定, 想要构建稳定系统, 复杂度非常高.

一般可以默认使用的网络是异步packet网络
一个packet是否到达, 何时到达都没有保证
- 请求没有发出去
- 请求排队后发出
- 请求在网络中排队
- 对方节点宕机接收不了
- 请求在对方节点内排队
- 对方节点临时宕机, 又恢复
- 响应在网络中丢失
- 响应过很久才抵达
即, 一个请求发出去, 除非被告知成功, 否则不知道会在哪里出问题, 应对这些问题的常用方法是超时, 即超过一定时间, 就认为失败, 同时要处理好幂等性, 避免老请求的影响

网络最大的不稳定是人, 配置出错根本没招

# 超时和 unbounded delays
超时是最佳实践, 但是这个时间设置多少合适?
- 太长: 等待太久
- 太短: 容易误判, 浪费资源
	- 误判导致动作执行两次, 没有幂等就会不一致
	- 如果系统已经高负载, 导致响应变慢, 此时如果快速超时, 会导致整个系统连环崩溃(越宕机, 剩余的节点负载越大, 越慢, 然后宕机更严重)

一个理想情况是, 构建一个网络时延不超过d的网络, 所有请求都能在d时间内到达, 或者丢失, 不会有超过d时长的成功请求, 如根据此假设,  2d+r, r是单个响应最长处理时间, 就是一个很好的阈值, 这是有界网络的好性质

不过现实没有这个保证, 特别是异步网络, 是无界的, 

# 网络拥塞与数据包排队
- 去程网络排队, 交换机对同一个目标的包要进行排队操作
- 目的机器排队, 机器负载高, 必须等待cpu处理
- 虚拟机排队, 虚拟化环境中, cpu不是独占, 需要等待cpu资源
- TCP流量控制, 会限制流量, 可能要在本机排队
此外, 如果发生了重试/重传, 此前的失败也计入时延.

一个基本的现象是, 网络拥塞程度越高, 时延越大

此外, 除了外部网络和目标机器, 本机如cpu资源紧张. 也会受到影响

具体超时时长需要根据上述因素综合考虑得到
如Phi故障累计检测算法, 类似tcp重传间隔

## 选择协议
tcp的拥塞避免和流量控制也导致了高负载时, 时延较高
udp由于不做流量控制, 所以延迟可以较低
但可靠性差, 如果需要一定程度保证, 可以在应用层做更多保证
一般的:
- 在特殊场景, 使用底层, 粗糙协议
- 在通用场景, 使用封装好的协议

即如果需要特殊性能, 就自己在时延和可靠性上做tradeoff, 制定好协议

# 同步和异步网络

同步网络如电话网络, 是不可行的, 纯物理组网+电路交换, 其灵活性与分组交换网络不可相比

特别的, 有两大缺点:
- 无法应对突发峰值流量, 此时分组交换网络可以让更大面积的网络承担流量, 但是电路网络不行
- 异构性造成极大复杂度, 在此基础上更难搭建带宽合适的电路网络