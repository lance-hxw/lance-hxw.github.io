分布式系统的特点:
- 进程间不能共享内存, 只能消息传递
- 只能通过网络通讯, 但是:
	- 不可靠
	- 且无界的延迟
- 需要处理不可靠时钟的时钟漂移问题
- 需要处理任何可能的进程停顿

分布式系统最大的复杂度来源就是: 不能确信任何事情,即:
- 只能通过网络中得到的回复来进行**推测**
- 只能和其他节点**交换信息**来确定状态
- 如果一个节点没有响应, 无法分析是哪里的问题

于是, 对分布式系统的讨论走向了什么是真相

我们无法去获取完全可靠的系统,但是可以:
- 做出基本假设, 保证这些功能的可靠
- 构建出不完全可靠的系统
- 利用能被证明正确性的算法, 利用不可靠的系统实现整体相对可靠性, 如TCP

这个系统设计过程主要涉及:
- 对底层作什么假设
- 对上层提供什么承诺

# 多数派就是真相
- 如果一个节点正常工作, 但是断网, 其他节点沟通不了, 就被认定死亡, 该节点完全不知情(收不到通知), 还在一直运行
- 如果一个节点正常工作, 他发现别人收不到他的消息, 但是没有办法, 也相当于死亡
- 一个节点gc时stw了1分钟, 超过阈值, 被判定死亡, 但是进程这里根本没有发现问题, 因为他没有意识到自己停顿了多久

综上, 一个节点根本判断不了自己能不能正常工作, 也就做不了故障的处理, 更无法保证系统的可靠性

所以一个分布式系统不能有单点故障, 因为单点随时可能故障, 而可能故障就一定会故障, 此时系统就会宕机.

所以几乎所有的分布式算法都有一个quorum 法定人数, 任何决策达到法定人数才能通过, 避免单点依赖

最常用的, 就是多数派, 即过半, 此时可以容忍接近一半的节点故障

# 领导者与锁

为了系统中数据一致性, 往往会要求全局唯一性:
- 数据系统唯一主节点, 避免脑裂
- 资源或者对象的唯一锁, 避免并发写入或者删除带来的写冲突
- 业务上, 名字, id等应该唯一, 用于区分实体

在分布式系统中, 这种唯一性保证需要小心处理, 因为节点本地同样无法确认唯一性

## 锁 / 租约
用锁或者租约来控制这种唯一性, 或者说一致性, 是一种自然的转换, 而不是问题的解决, 他只是对资源的抽象.

此时问题转移成, 如何保证锁持有者的唯一性

最常用的方法, 是, 用一个防护令牌, 即一个token, 一般是一个递增的数字, 资源控制者会校验这个token, 就算token持有者stw了10分钟, 早已过期, 他也意识不到, 当他请求过来的时候, 资源控制者会直接拒绝他

基于递增数字的token处理也很简单, 只要判断有没有处理过更大的token就行了
- 不过这token的一致性也需要保证
- ...所以还是转移, 而不是解决
- 最终复杂度来到了zk, 依赖分布式协调算法实现了一致性

这种处理方式也隐含了一种思想: Zero Trust

# 拜占庭错误

防护令牌只能阻止无意的错误, 如果有攻击者, 那就没招了

此前假定了节点是不可靠的, 但是一定诚实的.
如果节点有谎言(被劫持或者错误), 那麻烦就大了, 比如收到了消息却说没有, 或者反之

此类错误就是: 拜占庭故障 byzantine fault
在可能存在拜占庭故障的环境中达成共识, 这个问题就是拜占庭将军问题 byzatine generals problem.

## byzatine generals problem

是"两将军问题"的泛化:
- 一个需要达成作战计划的场景
- 有两只军队, 在两个不同地方, 只能用信使通讯
- 信使会迷路, 迟到

而拜占庭版本, 有n个将军, 且其中有叛徒, 不过大部分是忠诚的, 叛徒则需要保持隐蔽+欺骗其他人

## byzatine fault-tolerant
拜占庭容错, 指部分节点有故障且不遵循协议, 或者会恶意攻击系统, 但是系统还能正常运行, 就称为拜占庭容错的
- 航天环境有高能辐射, 数据会出错, 但是要保持不宕机
- 多方会谈中, 不能被其他人欺骗, 如区块链

不过, 大部分系统都没有拜占庭故障, 因为数据中心中的节点一般都不会成为肉机
(还有就是, 拜占庭容错复杂度太高, 根本不可接受)

- 服务端确实会遇到不可信前端的欺骗, 但是这不需要byzatine容错, 而是进行校验就行
- byzatine容错意义不是很大, 如果攻击者能拿下一个系统中的一个节点, 他往往能拿下别的节点, 除非系统高度异构, 不过这很少见 

# 弱谎言 week forms of lying 防护

弱谎言, 指的是硬件/软件bug, 错误配置等造成的非法信息.

虽然byzatine容错不太可行, 但是对弱谎言进行防护还是必要且有效的:
- 应用层校验: 解决os, 磁盘, 网络中数据的出错
- 过滤用户输入的值, 特别是别被sql注入
- ntp多源同步



# 现实中的系统模型

对分布式系统的算法设计非常多, 他们被用于处理本章提到的各种问题, 从而让分布式系统变得实际可用, 即实现了"用不可靠组件搭建可靠系统", 这些"使...可靠的"算法非常重要

在进行算法设计的时候, 不应该高度依赖具体组件, 所以需要进行一定的抽象, 即进行系统模型的抽象.

## 时间模型

- 同步模型: 网络延迟, 进程停顿, 时钟错误都是有界的, 不现实, 实际上这些都是无界的 
- (最常见)半同步模型, 在大部分情况下都是有界的, 偶尔超时, 不过我们需要对这些偶尔情况做好最坏打算
- 异步模型: 可以认为时钟不存在, 此时超时也没用(任何机器都不能依赖时钟), 这几乎没法用
## 节点故障
- 宕机停止, 宕机后节点直接下线, 并且不上线
- (最常见)宕机恢复, 可以恢复, 但是需要时间不一定
- 拜占庭任意故障 byzatine (arbitrary) faults: 不一定能恢复, 而且也不知道是恶意还是正常
## 现实系统

半同步+宕机恢复, 就是我们正常需要搭建的系统模型
## 算法的正确性

我们在设计解决问题的算法时必须要关注其正确性, 如:
- 对排序算法: 任意两个元素, 左边的更小
同理, 对于分布式算法, 如:
- 对防护令牌+锁, 要求:
	- 唯一性: 两个不同请求不能持有一个锁的相同令牌
	- 单调有序性: 不能后来者拿到更早的令牌
	- 可用性: 如果请求了一个令牌, 就一定会受到响应

对于任意系统模型, 一个算法能应对所有出现
的问题(或者我们期望要解决的问题), 并且在任意时刻都能满足约束, 我们就称为正确的算法.

不过如果所有节点都当或者无界延迟, 那么没算法能解决, 这也不是我们期望能解决的

## 安全性和存活性
在算法正确性中, 这二者是不同的

- safety: 如唯一性和单调性
- liveness: 如可用性

存活性一般都会

## 系统模型与现实世界

