在无主模型上, 任何副本都能写
在关系型数据库中, 无主模型几乎绝迹, 但是在dynamo论文开始, 又出现了一批dynamo-style的数据库, 如cassandra, riak等

无主模型一般的特性是:
- 客户端直接写入副本
- 用一个"协调者"接收写入, 但是这个协调者不是主副本, 他不负责处理顺序

无主模型的最关键概念就是多数
# 写入
有主副本, 如果主副本宕机, 就要转移等操作
但是无主构型中, 直接忽略宕机副本即可, 直接强行写, 只要有多数节点存活

不过写非常方便, 读取的时候就需要处理, 需要同时读取多个副本, 选取最新版本的值

# 读时修复和反熵
如何处理故障节点重启后的数据同步呢?
dynamo-style中有两种机制:
- read repair: 读取的时候发现部分节点是旧数据, 就将旧的修改掉
- anti-entropy process: 一种兜底修复, 因为有的旧数据没读就不会发现, 所以用一些后台程序持续寻找并更新
# quorum 读写
如果n个副本, 写入w个才认为写成功, 并且在查询时最少需要读r个节点
那么, 只要w+r>n, 我们才能读取到新数据(鸽巢)
- 根据版本号确定新旧
此时w和r的值组成quorum读写, 这个约束是保证机制有效的最低票数

在dynamo-style中, n,r,w是可以配置的
- n越大, 冗余度越高, 约可靠
- r, w一般都超过半数
- w足够高时, r可以小, 甚至w=n, r=1, 此时读很快

只要w<n, 就可以容忍部分节点不可用时写, r同理



# quorum一致性的局限
#TODO 

# 放松Quorum 和提示转交

# 并发写入检测
对于多个写入的关系检查
## LWW
后者胜就是, 通过某个手段得到一个全局唯一的顺序(全序), 然后让后面的覆盖前的
这个一般可以用全局时间戳实现
lww有一个问题, 如果多个并发写入的客户端同时写入成功, 最后只能有一个值保留, 就有读-写不一致, 即不是自己写的数据
lww唯一安全的使用方法是, key只能写一次, 后面就变成只读, 比如cassandra就建议用uuid当主键, 每个写都只能有一个唯一key

## happens-before 与并发

任意两个写入a和b, 只有三种关系:
- a happens-before b
- b happens-before a
- ab并发
### 如何确定happens-before关系

版本号, 物理时钟, 或者逻辑时钟[[逻辑时钟与物理时钟]]
- 多副本不能用单个版本号