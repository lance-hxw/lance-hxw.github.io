多副本好处多多:
- 高可用: 允许节点故障, 可以进行恢复和转移
- 伸缩性: 便于拓展
- 低延迟: 可以使用最高效的副本去读数据

但是对于最常见的读多写少场景, 如果使用同步复制, 必然出现写阻塞
若做成异步复制, 又会出现不一致问题.
但是一般来说, 我们认为只要网络正常, 写的滞后不会特别久, 会达成最终一致性
但是, 对于分布式系统, 这个假设随时可能不成立, 在网络分区和机器高负载时, 随时可能出现复制滞后

最终, 是一个非常不精确的限定词, 包含了太多可能(最终是最终了, 但是等了很久很久)

所以最终一致性的系统, 必须要解决复制滞后问题带来的不一致

# 读自己写
在一个异步复制的分布式数据库中, 同一个客户端, 写完数据(写在主副本)后立马读(读在从副本), 就发现读不到自己写的数据.

这是非常反直觉的, 必须要解决, 所有有了"读写一致性" , read-after-write consistency
这种一致性是对**单个客户端**进行保证的, 即一个客户端能立马读到其刚写的内容

## 如何实现读写一致性
### 内容分类
对某一个客户端可能会修改的内容, 直接强制读主副本
如对于个人资料, 读自己的资料(当前客户端可能写)就从主副本读取, 读别人资料就可以去从副本读
### 时间分类
内容分类方案显然不太可行, 因为这样只要修改就全在主节点上了
所以可以把近期修改的数据设置为从主副本读, 其他去从副本.
这个"近期"的识别:
- 阈值一般设置为从副本一段时间内的最大延迟
- 在哪去判定这个路由呢
	- 必定是服务端
		- 前端根本不可信任
		- 实现方式
			- 在智能代理层, 理解数据分片, 和主从复制状态
			- 查询或者缓存数据项的最后修改时间戳, 然后对比修改状态
			- 这个查数据修改时间操作, 一般用一个高性能kv存储来实现, 将其缓存化
			- 如果需求更高， 可以直接变成本地缓存
### 时间戳
记录本客户端上次写的时间戳, 然后拿这个时间戳去读数据库, 找一个已经同步到时间戳之后的副本, 或者阻塞到某个副本同步到时间戳之后, 再进行读.

时间戳可以是逻辑上的, 也可以是物理上的

### 特殊问题

- 如果数据分布在多个数据中心, 那么发给主副本的请求都要先去找主副本的数据中心
- 如果一个逻辑用户有多个物理客户端, 此时如果他用电脑改了数据, 手机刷新查不到, 体验也很差
	- 这种就不能用设备id去做一致性保证, 而需要对逻辑客户, 即用户id去做读写一致性
	- 这种一致性必须在服务端去做.

# 单调读
异步复制还可能代理时光倒流问题, 即每次读请求路由到不同的节点, 节点的同步进度不同, 先访问到新的, 又访问旧的, 导致了不一致. 

这种一致性保证是"单调读一致性"
- 读写一致性是先写后读的一致性
- 单调读一致性是连续多次读之间的一致性

## 如何实现单调读
### 只从一个副本读
最朴素的思想就是, 如果一个客户端的多次读都在一个副本上进行, 自然就不会有不一致
- 这种实现可以根据id去hash分组
### 时间戳
即上一次读也记录时间戳, 不能访问比这个时间戳更早的副本

# 一致前缀读
异步分支还会带来因果的错乱, 两个有前后关系的数据在不同分区进行, 就导致顺序错乱
- 比如读写, 读读, 写读等等等等.
这种一致性问题称为 一致前缀读

## 如何实现一致前缀读
### 直接不分区

### 让有因果(顺序)关系的事件路由到一个分区
- 但是如何认证因果关系有问题

# 真正的解决方案: 事务
读自己写, 单调读, 一致前缀读, 这些一致性都可以用事务解决. 
单机事务已经非常成熟, 但是在分布式场景很多nosql都抛弃了事务:
- 为了更容易的实现
- 为了更好的性能
- 为了高可用
所以分布式系统中这部分的一致性复杂度要在应用层做,

这是数据库对于分布式系统多副本多分区的一种妥协, 事务还需要更多更好的实现方式

也有很多分布式数据库开始支持事务, 即分布式事务


