每一份叫做replica副本, 涉及写的冗余设计主要的问题是: 如何保证写同步到所有副本

基于领导者的同步方案是最常见的

# 基本概念
- 其中一个副本是leader, 或者叫 primary, master. leader是写入的协调者, 写都要发给leader
- 其他副本是follower, 或者叫 read replica, slave, secondary, hot-standby(热备)
- leader将写同步到各个副本, follower接受变动应用到自己的状态机
	- 这个过程是日志同步, 或者变更流
- 读取: 可以从主或者从中读取
- 写:只能写主副本
# 同步/异步复制

同步和异步的主要区别在于, 合适将请求返回给客户端
- 同步复制: 等待follower写完再发送响应
- 异步复制: leader执行了写, 立即响应, 然后同步到follower

其权衡:
- 同步复制 响应延迟高, 牺牲可用性(follower单点故障), 一致性好(但不完全保证)
- 异步复制 一致性更松, 写入延迟低, 较高可用性

实践:
- 全同步, 对所有副本都同步写, 需要并行写或者流水线, 且可用性差
- 半桶不, 部分同步, 部分异步
- 全异步, 网络好可以, 网络差会不一致

异步最主要的缺点不一致, 后续有链式复制等方式, 兼顾一致性和性能

# 新增(扩展)副本

在需要扩展时, 如果副本是可读的非常简单, 可写的就比较复杂.

最朴素的方案是, 停止写, 然后拷贝, 比如低谷期进行. 

不停机方案: 
- 主副本 dump一个一致性快照
- follower拉取快照
- follower从leader获取快照后的变动, 要有序列号
- 追上后进入正常同步状态
# 宕机处理

## leader宕机
主要分三步:
- 确认leader宕机
	- 防止网络抖动的误判, 一般用心跳
- 选新leader
	- 一般基于共识算法进行选举, 或者直接外部指定
	- 选leader要选数据最新的
- 全局感知新leader
	- 让其他follower, 所有client, 和之前宕机的leader感知新leader的出现
	- 新leader要在其上线时进行状态改变, 防止脑裂
### 主副本切换问题
- 新老leader数据冲突, 老leader上有部分数据没有同步到新leader上
- 外部系统冲突, 新leader中的数据和外部系统不一致(在老leader写, 随即丢失)
- 脑裂, 一般会自动关闭一个, 设计不好可能会同时宕机
- 超时阈值选取: 防止误判, 防止主副本频繁切换, 又要让故障及时转移提升可用性
一般上线初期手动切换更方便, 成熟后自动化
## follower宕机
类似新增follower, 进行同步就行了

# 日志复制

一个写, 或者说修改在数据系统的不同层级表现为:
- 查询层: 语句
- 存储层:
	- 存储引擎相关的 预写日志
	- 存储引擎无关的 逻辑日志
- 应用层: 触发器逻辑
## 语句复制
leader记录所有写操作的语句, 然后同步给follower, 此时leader相当于一个伪客户端对从库进行访问
主要问题:
 - 非确定性函数带来不一致: now, rand
 - 强顺序要求,如果执行顺序不一致, 自增或者依赖当前数据的操作都会造成不一致
 - 有副作用的语句可能在不同副本的上下文中造成不同结果
 
可能的解决方案:
- 识别出所有此类操作
- 对此类操作直接同步值(如now, rand 改写成直接设置值)
## WAL 预写日志(如redo log) 关注备份重放
预写日志是和磁盘高度相关的, 其记录的是和存储引擎耦合的, 是存储页面的实际变动
如: seq+页面id+偏移量+旧数据+新数据+校验和

两大类存储引擎都有wal:
- 对于log-structure, 每次写操作都先写log文件, 防止memtable丢失
- 对于update-in-place, 每次修改都写wal,  用于崩溃修复

最终到达存储引擎后, 其至少要对wal实现:
- 追加写
- 可重放

wal的这种结构就满足了备份同步的需求, 且与磁盘非常契合
- 磁盘适合顺序写, 网络只能流式写

基于wal的同步即:
- 主副本写wal的同时, 将对应日志也发送给所有从副本

### 升级问题:
若需要对存储集群升级
- 如果允许旧版本代码给新版本代码发日志, 就可以先升级从库再升级主库
	- 也就是旧的主库多存在一会
	- 即兼容新版本(前向兼容)
## 逻辑日志(基于行, 如binlog) 更多 用于同步 和审计
与具体存储引擎解耦, 使用逻辑日志进行同步
在关系型数据库中, 一般都是用一个行上的逻辑进行同步

- 插入: 日志应该包含所有值
- 删除: 日志应该包含待删除的行的标志, 如主键等
- 更新: 日志应该包含需要更新的行标志, 和至少需要更新的列值

对于多行操作如事务, 一般是在若干修改后增加一条事务提交的记录

主要优点: 
- 兼容性好
- 与存储引擎松耦合
- 允许用于各种变换, 进行分析和使用
## 触发器日志
有些数据库会提供一些工具, 或者使用触发器和存储过程, 实现:
- 对部分数据进行过滤, 复制这个子集
- 将数据迁移到另一个数据库

基于触发器的复制性能一般较差且不稳定, 不过是为了灵活的需求.