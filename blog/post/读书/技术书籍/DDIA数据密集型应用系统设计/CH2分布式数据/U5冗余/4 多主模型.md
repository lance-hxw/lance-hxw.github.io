单主模型最大问题是所有写都要过leader, 只要连不上主副本, 就写不了
- 主副本宕机
- 网络问题连不上主副本

多主模型即, 有多个可以写的节点, 每个主节点写入后都要同步给其他副本
# 应用场景
如果是单数据中心, 意义不大, 需要多主的出发点并非写入并发不足, 而是和网络和可用性相关
而且多主会严重影响一致性
但是有特定场景需要:
- 多数据中心
- 离线工作的客户端
- 协同编辑
## 多数据中心
此时一个客户端的写请求, 很可能要发到很远的数据中心再同步到附近的中心.
此时相比单主模型:
- 可以就近写, 结合异步复制, 写入延迟很低
- 每个副本都可以写, 网络分区可以保证高可用(但是一致性会差)
- 网络容错高, 如果客户端连不上某个主节点, 还可以去别的节点写
但是, 多数据中心+多主节点带来了非常复杂的一致性问题, 特别是同时修改如何解决冲突.
自增主键, 触发器, 完整性约束等都很难保证, 所以基本不用.

## 离线客户端
只要你的客户端支持同步的同时还支持离线修改可以同步的数据, 就实质上等价于多主模型.
- 相当于分区了的多主
在重新联网同步时就要处理一致性问题, 这很难.

## 协同编辑

多人编辑一个数据, 也是一种逻辑上的多主模型, 即我可以立即修改看到的内容, 而不是按一个个"commit"进行修改.
这种一般这样解决:
- 悲观: 加锁, 直接按小粒度加锁
- 乐观: 无脑写, 然后发生冲突直接覆盖或者concat等, 然后用户自己解决.

# 写入冲突

多主模型最主要的缺点就是写入可能发生冲突, 如:
- user1, 将数据从A改成B
- user2, 将数据从A改成C
两人都完成了写, 现在两个主节点不一致, 如何解决?

## 冲突检测
单主模型, 由于只在一个副本写, 所以可以这样做:
- 让第二个写直接阻塞, 等待第一个写完成
- 第二个主写不了, 失败, 重试
但是多主模型两个副本都成功了, 是在同步时发生了冲突.
一种方法是在多主间完成同步后将结果返回客户端:
- 此时多主之间进行同步复制
- 相当于多主融合成单主, 且延迟飙升

## 冲突避免
设计上避免冲突是最优解, 所以经常使用

如果数据可以较好的分割, 就可以将不同子集的主副本放在不同数据中心:
- 即形成一种特殊的数据分片, 即每个数据只能在一个特定的主节点写,其他节点只有其副本
主要问题:
- 如果用户去别的地方, 他的数据需不需要迁移
- 如果一个数据中心损坏了, 部分数据的写就需要重新找一个主节点安置
## 冲突收敛

单主模型对顺序比较好处理, 所以可以用覆盖的方式直接覆盖前一个写入.
但是多主模型没办法确定顺序(多个主节点上都完成了, 现在只是在同步)

那么如何在无权威的情况下完成最终副本的收敛呢(convergent)

可以基于规则:
- 对每个写入都设置序号, 规定新的优先
	- 相当于使用一个额外的外部系统对所有事件定序
	- 但是可能数据丢失, 冲突直接干掉其他写, 肯定不一致
- 给每个副本一个需要, 序号高的副本优先
	- 同理, 在低序号的主副本的写也会丢失, 然后不一致
- 自动冲突合并规则:
	- 比如对字符串, 直接拼接, 这个一般用于c端用户吧
- 使用程序定制一种保留所有冲突信息的方案, 同时可以让用户决定, 即保留信息不丢弃, 但是还是存在冲突


## 自定义解决
综上, 多主模型冲突根本无法基于系统设计解决, 即技术解决不了业务的问题.
由于只有用户知道真正的细节和全貌, 所以让用户进行一致性协调是最好的方案
即, 允许用户编写回调代码, 用于解决冲突.
- 写时执行: 若写入出错, 就调用, 按规则解决冲突, 这个不能同步, 也是异步的
	- 如果这里同步, 整个写操作就变成同步的了
- 读时执行: 使用保留所有信息的方式完成正常的写入过程, 在读的时候调用冲突解决方法, 将数据处理, 然后回写系统
	- 这个操作应该是交互式的, 让用户决定的
	- 如果只是后台运行一个脚本, 那应该直接写入时执行
## 如何界定冲突
比如对同一条记录, 一个key对应的数据的写
有的比较隐晦, 比如对同一个会议室的相同时段, 所以冲突界定也比较麻烦

# 多主复制的拓扑结构
只有两个主副本, 拓扑很简单, 即二者互相发送
但是在超过3个后, 就有比较多的形式了:
- 环形拓扑: 单向环形同步更新
	- 通讯跳数少, 但是总要带上路径上所有更新消息. 并且一个节点故障将导致整个系统宕机
- 星形拓扑(集线器):
	- 一个主节点负责接收和转发, 存在单点故障
- 全链接, 冗余度高, 容错较好

对于环形和星型, 由于不是端到端, 存在广播风暴问题, 所以需要对所有的节点有唯一标记, 即指明接收者, 实现端到端, 接收到后及时丢弃并终止消息的传播

全链接的最大问题是, 不同的复制链接速度不一致
即: ash 和bob对A和B节点发起修改, ash先, bob后, 但是C主节点里A很远
此时C先收到Bob的修改, 后收到Ash的修改

这就需要全局排序, 但是只用A和B的物理时钟作为标记是不行的
- 物理时钟不同步
- 可能时钟回退
还有一种版本向量策略, 可以对多副本事件进行排序, 解决因果一致性(单调读)

# 多主模型缺点非常多, 一定要用, 就得注意这些问题
